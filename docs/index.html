<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Opera in Venice: Analytics Dashboard</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <!-- noUiSlider CSS (Pour le slider de plage temporelle) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.css" />
    
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary-color: #d62828;
            --secondary-color: #003049;
            --bg-light: #f8f9fa;
            --border-color: #dee2e6;
        }

        body {
            margin: 0; padding: 0;
            font-family: 'Roboto', sans-serif;
            display: grid;
            height: 100vh;
            width: 100vw;
            /* Layout: Sidebar (gauche), Carte (haut droite), Timeline (bas droite) */
            grid-template-columns: 300px 1fr; 
            grid-template-rows: 1fr 120px;
            grid-template-areas: 
                "sidebar map"
                "sidebar timeline";
            overflow: hidden;
        }

        /* 1. SIDEBAR (FILTRES À FACETTES) */
        #sidebar {
            grid-area: sidebar;
            background: #fff;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 5px rgba(0,0,0,0.05);
            z-index: 1000;
        }

        .sidebar-header { padding: 20px; border-bottom: 1px solid var(--border-color); background: var(--bg-light); }
        .sidebar-header h1 { font-size: 18px; margin: 0; color: var(--secondary-color); }
        .sidebar-header p { font-size: 12px; color: #666; margin: 5px 0 0 0; }

        .filters-container { padding: 15px; overflow-y: auto; flex-grow: 1; }

        /* Style des catégories de filtres */
        .facet-group { margin-bottom: 20px; }
        .facet-title { 
            font-weight: 700; font-size: 13px; text-transform: uppercase; 
            color: var(--secondary-color); margin-bottom: 10px; display: block;
            border-bottom: 2px solid #eee; padding-bottom: 4px;
        }
        
        .checkbox-list { max-height: 200px; overflow-y: auto; font-size: 13px; }
        .checkbox-item { 
            display: flex; justify-content: space-between; align-items: center; 
            padding: 3px 0; cursor: pointer; 
        }
        .checkbox-item:hover { background-color: #f0f0f0; }
        .count-badge { background: #eee; color: #666; padding: 1px 6px; border-radius: 10px; font-size: 10px; }

        .reset-btn {
            width: 100%; padding: 10px; background: var(--secondary-color); color: white;
            border: none; cursor: pointer; font-weight: bold; text-transform: uppercase;
            font-size: 12px;
        }
        .reset-btn:hover { background: #333; }

        /* 2. MAP */
        #map {
            grid-area: map;
            background: #e5e5e5;
        }

        /* 3. TIMELINE DASHBOARD */
        #timeline-panel {
            grid-area: timeline;
            background: #fff;
            border-top: 1px solid var(--border-color);
            padding: 10px 40px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
        }

        /* Histogramme */
        #histogram {
            width: 100%;
            height: 40px;
            display: flex;
            align-items: flex-end;
            margin-bottom: 5px;
        }
        .hist-bar {
            flex: 1;
            background-color: #e0e0e0;
            margin: 0 1px;
            transition: background-color 0.2s;
        }
        .hist-bar.active { background-color: var(--primary-color); }

        /* Slider Customisation */
        #time-slider { height: 10px; }
        .noUi-connect { background: var(--primary-color); opacity: 0.5; }
        .noUi-handle { border-radius: 50%; width: 18px; height: 18px; top: -5px; cursor: grab; box-shadow: none; border: 2px solid var(--primary-color); }
        .noUi-handle:before, .noUi-handle:after { display: none; }
        .slider-labels {
            display: flex; justify-content: space-between; margin-top: 10px;
            font-weight: bold; color: var(--secondary-color); font-size: 14px;
        }

    </style>
</head>
<body>

    <!-- Sidebar avec Filtres -->
    <div id="sidebar">
        <div class="sidebar-header">
            <h1>Venetian Opera Analytics</h1>
            <p>Exploration multivariée (1660-1760)</p>
        </div>
        
        <div class="filters-container">
            <!-- Les facettes seront injectées ici par JS -->
            <div id="facets-output"></div>
        </div>

        <div style="padding:15px;">
            <button class="reset-btn" onclick="resetAll()">Réinitialiser les filtres</button>
        </div>
    </div>

    <!-- Carte -->
    <div id="map"></div>

    <!-- Timeline & Slider -->
    <div id="timeline-panel">
        <!-- Histogramme visuel -->
        <div id="histogram"></div>
        <!-- Le Slider technique -->
        <div id="time-slider"></div>
        <!-- Labels de dates -->
        <div class="slider-labels">
            <span id="date-start">1660</span>
            <span id="info-selection" style="font-weight:normal; color:#666;">Chargement...</span>
            <span id="date-end">1760</span>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.js"></script>

    <script>
        // --- 1. CONFIGURATION & ÉTAT GLOBAL ---
        const CONFIG = {
            minYear: 1660,
            maxYear: 1760
        };

        // État de l'application (State management)
        let appState = {
            data: [],               // GeoJSON features
            filters: {},            // { theatre: Set(), compositeur: Set()... }
            timeRange: [1660, 1760]
        };

        let map, layerGroup;
        let slider;

        // --- 2. INITIALISATION DE LA CARTE ---
        function initMap() {
            map = L.map('map', { zoomControl: false }).setView([45.437, 12.335], 14);
            L.control.zoom({ position: 'topright' }).addTo(map);

            L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; CARTO',
                maxZoom: 19
            }).addTo(map);

            layerGroup = L.layerGroup().addTo(map);
        }

        // --- 3. CHARGEMENT ET PRÉPARATION DES DONNÉES ---
        fetch('sample_operas.geojson')
            .then(res => res.json())
            .then(geoJson => {
                appState.data = geoJson.features;
                
                initFacets();      // Créer les cases à cocher
                initSlider();      // Créer le slider et l'histogramme
                updateDashboard(); // Premier rendu
            });

        // --- 4. GESTION DES FILTRES (FACETTES) ---
        // Définition des catégories à filtrer
        const FACET_CONFIG = [
            { key: 'theatre', label: 'Théâtres' },
            { key: 'compositeur', label: 'Compositeurs' },
            { key: 'librettiste', label: 'Librettistes' }
            // Ajouter { key: 'genre', label: 'Genre' } ici plus tard
        ];

        function initFacets() {
            const container = document.getElementById('facets-output');
            
            FACET_CONFIG.forEach(facet => {
                // 1. Créer le conteneur HTML de la facette
                const groupDiv = document.createElement('div');
                groupDiv.className = 'facet-group';
                
                const title = document.createElement('span');
                title.className = 'facet-title';
                title.innerText = facet.label;
                groupDiv.appendChild(title);

                const listDiv = document.createElement('div');
                listDiv.className = 'checkbox-list';
                listDiv.id = `list-${facet.key}`;

                // 2. Extraire les valeurs uniques et compter
                const counts = {};
                appState.data.forEach(f => {
                    const val = f.properties[facet.key];
                    if(val) counts[val] = (counts[val] || 0) + 1;
                });

                // Trier par ordre alphabétique
                const sortedKeys = Object.keys(counts).sort();

                // 3. Créer les checkboxes
                sortedKeys.forEach(val => {
                    const item = document.createElement('label');
                    item.className = 'checkbox-item';
                    item.innerHTML = `
                        <span>
                            <input type="checkbox" data-category="${facet.key}" value="${val}" onchange="handleFilterChange()"> 
                            ${val}
                        </span>
                        <span class="count-badge">${counts[val]}</span>
                    `;
                    listDiv.appendChild(item);
                });

                groupDiv.appendChild(listDiv);
                container.appendChild(groupDiv);
            });
        }

        function handleFilterChange() {
            // Reconstruit l'objet appState.filters
            const filters = {};
            
            FACET_CONFIG.forEach(facet => {
                const checkedInputs = document.querySelectorAll(`#list-${facet.key} input:checked`);
                if (checkedInputs.length > 0) {
                    filters[facet.key] = new Set();
                    checkedInputs.forEach(input => filters[facet.key].add(input.value));
                }
            });
            
            appState.filters = filters;
            updateDashboard();
        }

        function resetAll() {
            document.querySelectorAll('.checkbox-item input').forEach(cb => cb.checked = false);
            slider.set([CONFIG.minYear, CONFIG.maxYear]); // Reset slider
            appState.filters = {};
            // Le slider trigger l'update, pas besoin d'appeler updateDashboard ici si le slider bouge
        }

        // --- 5. GESTION DU SLIDER & HISTOGRAMME ---
        function initSlider() {
            const sliderElem = document.getElementById('time-slider');
            
            // Création du slider noUiSlider
            slider = noUiSlider.create(sliderElem, {
                start: [CONFIG.minYear, CONFIG.maxYear],
                connect: true, // La zone colorée entre les poignées
                range: {
                    'min': CONFIG.minYear,
                    'max': CONFIG.maxYear
                },
                step: 1, // Pas d'un an
                tooltips: false
            });

            // Événement de mise à jour
            slider.on('update', function (values) {
                const start = Math.round(values[0]);
                const end = Math.round(values[1]);
                
                document.getElementById('date-start').innerText = start;
                document.getElementById('date-end').innerText = end;
                
                appState.timeRange = [start, end];
                updateDashboard();
                updateHistogramHighlight(start, end);
            });

            generateHistogram();
        }

        function generateHistogram() {
            // Calcule la distribution temporelle de TOUTES les données
            const yearsMap = new Map();
            for(let y = CONFIG.minYear; y <= CONFIG.maxYear; y++) yearsMap.set(y, 0);

            let maxCount = 0;
            appState.data.forEach(f => {
                const y = f.properties.annee; // Assure-toi que c'est un entier
                if(y >= CONFIG.minYear && y <= CONFIG.maxYear) {
                    const newVal = yearsMap.get(y) + 1;
                    yearsMap.set(y, newVal);
                    if(newVal > maxCount) maxCount = newVal;
                }
            });

            // Génère le HTML
            const container = document.getElementById('histogram');
            container.innerHTML = '';
            
            for(let y = CONFIG.minYear; y <= CONFIG.maxYear; y++) {
                const count = yearsMap.get(y);
                const heightPercent = maxCount > 0 ? (count / maxCount) * 100 : 0;
                
                const bar = document.createElement('div');
                bar.className = 'hist-bar';
                bar.dataset.year = y;
                bar.title = `${y}: ${count} opéras`;
                bar.style.height = `${heightPercent}%`;
                container.appendChild(bar);
            }
        }

        function updateHistogramHighlight(start, end) {
            // Change la couleur des barres selon si elles sont dans la plage
            document.querySelectorAll('.hist-bar').forEach(bar => {
                const y = parseInt(bar.dataset.year);
                if (y >= start && y <= end) {
                    bar.classList.add('active');
                } else {
                    bar.classList.remove('active');
                }
            });
        }

        // --- 6. CŒUR DU SYSTÈME : FILTRAGE ET RENDU ---
        function updateDashboard() {
            // A. Filtrer les données (Logique Croisée)
            const filteredFeatures = appState.data.filter(feature => {
                const props = feature.properties;

                // 1. Filtre Temporel
                const year = props.annee;
                if (year < appState.timeRange[0] || year > appState.timeRange[1]) return false;

                // 2. Filtres à Facettes (Catégories)
                // Pour chaque catégorie active (ex: Composer), l'objet doit matcher une des valeurs
                for (const [key, allowedSet] of Object.entries(appState.filters)) {
                    if (!allowedSet.has(props[key])) return false;
                }

                return true;
            });

            // Mise à jour texte info
            document.getElementById('info-selection').innerText = `${filteredFeatures.length} opéras sélectionnés`;

            // B. Agrégation Spatiale (Pour les cercles proportionnels)
            // On regroupe par Nom de Théâtre (ou coordonnées)
            const locations = {};

            filteredFeatures.forEach(f => {
                const theatreName = f.properties.theatre;
                if (!locations[theatreName]) {
                    locations[theatreName] = {
                        lat: f.geometry.coordinates[1],
                        lng: f.geometry.coordinates[0],
                        count: 0,
                        operas: [] // Pour la popup
                    };
                }
                locations[theatreName].count++;
                locations[theatreName].operas.push(f.properties);
            });

            // C. Dessiner sur la carte
            layerGroup.clearLayers();

            Object.keys(locations).forEach(key => {
                const loc = locations[key];
                
                // Calcul de la taille (Logarithmique ou linéaire)
                // Rayon min 5px, puis +3px par opéra (ajuster selon besoin)
                const radius = 5 + (Math.sqrt(loc.count) * 4); 

                const marker = L.circleMarker([loc.lat, loc.lng], {
                    radius: radius,
                    color: '#003049',
                    weight: 1,
                    fillColor: '#d62828',
                    fillOpacity: 0.6
                });

                // Popup riche
                let popupContent = `<strong>${key}</strong><br>`;
                popupContent += `<em>${loc.count} représentations sur la période</em><br>`;
                popupContent += `<div style="max-height:100px; overflow-y:auto; margin-top:5px; font-size:0.9em; border-top:1px solid #ccc;">`;
                
                // Lister les 5 premiers opéras (pour ne pas surcharger)
                loc.operas.slice(0, 10).forEach(op => {
                    popupContent += `• ${op.titre} (${op.annee})<br>`;
                });
                if(loc.operas.length > 10) popupContent += `... et ${loc.operas.length - 10} autres.`;
                popupContent += `</div>`;

                marker.bindPopup(popupContent);
                marker.addTo(layerGroup);
            });
        }

        // Lancement
        initMap();

    </script>
</body>
</html>