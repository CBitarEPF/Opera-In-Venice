<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Opera Venetia: Comparative Analytics</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Palette Sémantique */
            --primary: #9e2a2b;      /* Recherche A (Rouge historique) */
            --secondary: #219ebc;    /* Recherche B (Bleu analytique) */
            --gold: #e09f3e;
            
            /* UI Variables */
            --bg-panel: #ffffff;
            --bg-map: #e5e5e5;
            --text-main: #2b2d42;
            --border: #e9ecef;
            --bar-bg: #dcdcdc;
        }

        /* Dark Mode */
        body.dark-mode {
            --bg-panel: #1a1a1a;
            --bg-map: #121212;
            --text-main: #e0e0e0;
            --border: #333;
            --bar-bg: #333;
        }

        body {
            margin: 0; padding: 0;
            font-family: 'Lato', sans-serif;
            color: var(--text-main);
            background: var(--bg-panel);
            display: grid;
            height: 100vh; width: 100vw;
            grid-template-columns: 340px 1fr; 
            grid-template-rows: 1fr 150px;
            grid-template-areas: "sidebar map" "sidebar timeline";
            overflow: hidden;
            transition: background 0.3s, color 0.3s;
        }

        /* --- 1. SIDEBAR --- */
        #sidebar {
            grid-area: sidebar;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex; flex-direction: column;
            box-shadow: 4px 0 15px rgba(0,0,0,0.05);
            z-index: 2000;
        }

        .sidebar-header {
            padding: 20px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--gold);
        }

        .header-top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .app-title { font-family: 'Playfair Display', serif; font-size: 22px; margin: 0; color: var(--primary); }
        .burger-btn { background: none; border: none; font-size: 20px; color: var(--text-main); cursor: pointer; }

        /* Switch Mode Comparaison */
        .mode-switch-container {
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(0,0,0,0.03); padding: 10px; border-radius: 6px;
        }
        .switch-label { font-size: 0.9em; font-weight: bold; display: flex; align-items: center; gap: 8px; }
        
        /* Toggle Switch CSS */
        .switch { position: relative; display: inline-block; width: 36px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-round { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider-round:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider-round { background-color: var(--secondary); }
        input:checked + .slider-round:before { transform: translateX(16px); }

        /* Onglets A/B */
        .tabs-container { display: none; border-bottom: 1px solid var(--border); }
        body.compare-mode .tabs-container { display: flex; }
        .tab { flex: 1; padding: 12px; text-align: center; cursor: pointer; font-weight: bold; font-size: 0.9em; border-bottom: 3px solid transparent; opacity: 0.6; transition: 0.3s; }
        .tab:hover { opacity: 1; background: rgba(0,0,0,0.02); }
        .tab.active { opacity: 1; border-bottom-color: currentColor; }
        .tab-a.active { color: var(--primary); background: rgba(158, 42, 43, 0.05); }
        .tab-b.active { color: var(--secondary); background: rgba(51, 92, 103, 0.05); }

        /* Zone Filtres */
        .filters-wrapper { flex-grow: 1; overflow-y: auto; padding: 0 20px; }
        
        .search-box { margin: 15px 0; }
        .search-input { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; background: var(--bg-panel); color: var(--text-main); box-sizing: border-box; }

        /* Accordéons Facettes */
        .facet-group { border-bottom: 1px solid var(--border); padding: 15px 0; }
        .facet-header { display: flex; justify-content: space-between; cursor: pointer; font-weight: 700; color: #666; text-transform: uppercase; font-size: 11px; letter-spacing: 1px; }
        .facet-header:hover { color: var(--primary); }
        .facet-content { margin-top: 10px; display: none; max-height: 250px; overflow-y: auto; }
        .facet-content.open { display: block; animation: fadeIn 0.3s; }
        
        .checkbox-item { display: flex; justify-content: space-between; align-items: center; padding: 4px 0; font-size: 13px; cursor: pointer; }
        .count-badge { background: rgba(0,0,0,0.05); padding: 2px 6px; border-radius: 4px; font-size: 10px; }

        .sidebar-footer { padding: 15px 20px; border-top: 1px solid var(--border); display: flex; gap: 10px; }
        .btn { flex: 1; padding: 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; text-transform: uppercase; }
        .btn-reset { background: #f0f0f0; color: #333; }
        .btn-export { background: var(--text-main); color: #fff; }

        /* New: Menu Tabs for Sidebar Navigation */
        .sidebar-nav {
            display: flex;
            border-bottom: 1px solid var(--border);
            background: rgba(0,0,0,0.03); /* Lighter background for the menu bar */
        }
        body.dark-mode .sidebar-nav {
            background: rgba(255,255,255,0.05); 
        }

        .nav-tab {
            flex: 1;
            padding: 12px 10px;
            text-align: center;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.95em;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: 0.3s;
        }
        .nav-tab:hover {
            color: var(--primary);
            background: rgba(0,0,0,0.01);
        }
        .nav-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: var(--bg-panel); /* Active tab matches panel background */
        }

        /* Adjust the filters wrapper to handle the new content structure */
        .filters-wrapper { 
            flex-grow: 1; 
            overflow-y: auto; 
            /* Remove padding here, we'll put it inside the content-tab */
            padding: 0; 
        }

        /* New: Content area for each tab */
        .content-tab {
            padding: 0 20px; /* Add back the padding only to the content area */
            display: none;
            height: 100%; /* Ensure content fills the wrapper */
        }
        .content-tab.active {
            display: block;
        }

        /* --- New Styles for Entity Lists --- */
        .entity-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        .entity-item {
            padding: 6px 0;
            cursor: pointer;
            border-bottom: 1px dotted var(--border);
            transition: 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
        }
        .entity-item:last-child {
            border-bottom: none;
        }
        .entity-item:hover {
            background: rgba(var(--primary-rgb), 0.05); /* Use RGB variable if defined, otherwise use a fixed color */
            background: rgba(0,0,0,0.05); 
        }
        .entity-name {
            font-weight: 500;
        }
        .entity-count {
            font-size: 0.8em;
            color: #999;
            background: var(--border);
            padding: 2px 5px;
            border-radius: 3px;
        }
        .placeholder-text {
            padding: 10px 0;
            font-style: italic;
            color: #999;
            text-align: center;
        }

        .detail-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.5em;
            margin-top: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--border);
            padding-bottom: 5px;
        }
        .back-button {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            margin-bottom: 15px;
            transition: 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .back-button:hover {
            background: var(--border);
        }
        .entry-item {
            padding: 10px 0;
            border-bottom: 1px dashed var(--border);
        }
        .entry-item:last-child {
            border-bottom: none;
        }
        .entry-id {
            font-weight: bold;
            color: var(--primary); /* Uses the active primary color */
            margin-bottom: 5px;
        }
        .entry-context {
            font-size: 0.85em;
            line-height: 1.4;
            padding-left: 10px;
            border-left: 2px solid #ccc;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        body.dark-mode .entry-context {
            border-left-color: #555;
        }

        /* --- 2. MAP --- */
        #map { grid-area: map; background: var(--bg-map); z-index: 1; }
        /* Animation fluide des cercles */
        .leaflet-interactive { mix-blend-mode: multiply; transition: r 0.6s cubic-bezier(0.25, 0.8, 0.25, 1), fill-opacity 0.3s; }
        /* En Dark Mode, multiply ne marche pas bien, on utilise screen ou normal */
        body.dark-mode .leaflet-interactive { mix-blend-mode: screen; }

        /* --- 3. TIMELINE --- */
        #timeline-panel {
            grid-area: timeline; background: var(--bg-panel); border-top: 1px solid var(--border);
            padding: 10px 40px; display: flex; flex-direction: column; position: relative; z-index: 1000;
        }

        .controls-row { display: flex; align-items: center; margin-bottom: 5px; }
        .play-btn { 
            width: 36px; height: 36px; border-radius: 50%; border: 2px solid var(--primary); color: var(--primary);
            background: none; cursor: pointer; margin-right: 20px; display: flex; justify-content: center; align-items: center; transition: 0.2s;
        }
        .play-btn:hover { background: var(--primary); color: white; }
        
        .date-display { font-family: 'Playfair Display'; font-size: 1.3em; font-weight: bold; margin-right: 30px; }
        .legend-item { display: inline-flex; align-items: center; gap: 6px; font-size: 0.9em; font-weight: bold; margin-right: 20px; }

        /* Histogramme Stacked */
        #histogram { flex-grow: 1; width: 100%; display: flex; align-items: flex-end; margin-bottom: 5px; height: 60px; }
        .hist-col { flex: 1; height: 100%; margin: 0 1px; position: relative; display: flex; flex-direction: column-reverse; }
        .bar-bg { position: absolute; bottom:0; width:100%; background: var(--bar-bg); z-index:0; transition: height 0.3s; }
        .bar-a { width: 100%; background: var(--primary); opacity: 0.7; z-index: 2; transition: height 0.3s; }
        .bar-b { width: 100%; background: var(--secondary); opacity: 0.7; z-index: 1; transition: height 0.3s; display: none; }
        body.compare-mode .bar-b { display: block; }

        /* Slider */
        #time-slider { height: 6px; border: none; background: transparent; }
        .noUi-connect { background: #666; opacity: 0.3; }
        .noUi-handle { width: 14px; height: 14px; border-radius: 50%; background: #444; border: 2px solid #fff; top: -4px; right: -7px; cursor: grab; box-shadow: none; }

        /* --- MENU BURGER (MODAL) --- */
        #menu-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.5); z-index: 5000; display: none;
            justify-content: center; align-items: center; backdrop-filter: blur(3px);
        }
        #menu-box {
            background: var(--bg-panel); width: 400px; max-width: 90%; padding: 30px;
            border-radius: 8px; box-shadow: 0 20px 50px rgba(0,0,0,0.3);
        }
        #menu-box h2 { margin-top: 0; font-family: 'Playfair Display'; color: var(--primary); border-bottom: 1px solid var(--gold); padding-bottom: 10px;}
        .menu-row { display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid var(--border); }
        .close-menu { width: 100%; padding: 12px; background: var(--text-main); color: var(--bg-panel); border: none; cursor: pointer; margin-top: 20px; font-weight: bold; text-transform: uppercase; }

        /* Animation Helper */
        @keyframes fadeIn { from { opacity:0; transform: translateY(-5px);} to { opacity:1; transform: translateY(0);} }
    </style>
</head>
<body>

    <div id="sidebar">
        <div class="sidebar-header">
            <div class="header-top">
                <h1 class="app-title">Opera Venetia</h1>
                <button class="burger-btn" onclick="toggleMenu()"><i class="fas fa-bars"></i></button>
            </div>

            <div class="mode-switch-container" id = "modeSwitch">
                <div class="switch-label"><i class="fas fa-balance-scale"></i> Mode Comparaison</div>
                <label class="switch">
                    <input type="checkbox" id="modeToggle" onchange="toggleMode()">
                    <span class="slider-round"></span>
                </label>
            </div>
        </div>

        <div class="tabs-container">
            <div class="tab tab-a active" onclick="switchTab('A')">Recherche A</div>
            <div class="tab tab-b" onclick="switchTab('B')">Recherche B</div>
        </div>

        <div class="sidebar-nav">
            <div class="nav-tab active" data-content="operas-content" onclick="switchSidebarTab('operas')">Opéras</div>
            <div class="nav-tab" data-content="entities-content" onclick="switchSidebarTab('entities')">Entités</div>
        </div>

        <div class="filters-wrapper">
        
            <div id="operas-content" class="content-tab active">
                <div class="search-box">
                    <input type="text" id="searchInput" class="search-input" placeholder="Rechercher (Titre, Théâtre, Compositeur)..." onkeyup="handleSearch()">
                </div>
                
                <div id="facets-output">Chargement...</div>
            </div>
        <div id="entities-content" class="content-tab">
            
            <div id="entity-list-view">
                <p style="margin: 15px 0 10px; font-size:0.9em; font-style: italic; color:#888;">Sélectionnez une entité ci-dessous pour lancer une analyse comparative dédiée. Les nombres indiquent le nombre d'entrées de référence dans le corpus.</p>

                <div class="facet-group">
                    <div class="facet-header" onclick="toggleFacetContent(this)">
                        <span>Lieux</span> 
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="facet-content">
                        <ul id="entities-loc-list" class="entity-list">
                            <li class="placeholder-text">Chargement des entités...</li>
                        </ul> 
                    </div>
                </div>

                <div class="facet-group">
                    <div class="facet-header" onclick="toggleFacetContent(this)">
                        <span>Compositeurs/Librettistes</span> 
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="facet-content">
                        <ul id="entities-comp-libr-list" class="entity-list">
                            <li class="placeholder-text">Chargement des entités...</li>
                        </ul>
                    </div>
                </div>

                <div class="facet-group">
                    <div class="facet-header" onclick="toggleFacetContent(this)">
                        <span>Théâtres</span> 
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="facet-content">
                        <ul id="entities-thea-list" class="entity-list">
                            <li class="placeholder-text">Chargement des entités...</li>
                        </ul>
                    </div>
                </div>

                <div class="facet-group">
                    <div class="facet-header" onclick="toggleFacetContent(this)">
                        <span>Acteurs/Actrices</span> 
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="facet-content">
                        <ul id="entities-act-list" class="entity-list">
                            <li class="placeholder-text">Chargement des entités...</li>
                        </ul>
                    </div>
                </div>

                <div class="facet-group">
                    <div class="facet-header" onclick="toggleFacetContent(this)">
                        <span>Autres</span> 
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="facet-content">
                        <ul id="entities-misc-list" class="entity-list">
                            <li class="placeholder-text">Chargement des entités...</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div id="entity-detail-view" style="display:none;">
                <div style="padding: 10px 20px;">
                    <button class="back-button" onclick="showEntityList()">
                        <i class="fas fa-chevron-left"></i> Retour à la liste
                    </button>
                    <h3 id="detail-entity-name" class="detail-title"></h3>
                    <div id="detail-entry-list">
                        </div>
                </div>
            </div>

        </div>
        </div>

        <div class="sidebar-footer">
            <button class="btn btn-reset" onclick="resetCurrent()"><i class="fas fa-undo"></i> Reset</button>
            <button class="btn btn-export" onclick="exportData()"><i class="fas fa-file-csv"></i> Export</button>
        </div>
    </div>

    <div id="map"></div>

    <div id="timeline-panel">
        <div class="controls-row">
            <button class="play-btn" onclick="togglePlay()"><i id="play-icon" class="fas fa-play"></i></button>
            <div class="date-display" id="date-display">1660 - 1760</div>
            
            <div class="legend-item" style="color:var(--primary)">
                <i class="fas fa-circle"></i> <span id="count-a">0</span>
            </div>
            <div class="legend-item" id="legend-b" style="color:var(--secondary); display:none;">
                <i class="fas fa-circle"></i> <span id="count-b">0</span>
            </div>
        </div>

        <div id="histogram"></div>
        <div id="time-slider"></div>
    </div>

    <div id="menu-overlay" onclick="if(event.target==this) toggleMenu()">
        <div id="menu-box">
            <h2>Paramètres & Infos</h2>
            
            <div class="menu-row">
                <span><i class="fas fa-moon"></i> Mode Sombre</span>
                <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()">
            </div>

            <div class="menu-row">
                <span><i class="fas fa-map"></i> Fond de carte</span>
                <select id="mapStyle" onchange="changeMapStyle(this.value)" style="padding:5px;">
                    <option value="voyager">Voyager (Clair)</option>
                    <option value="dark_all">Dark Matter (Sombre)</option>
                    <option value="light_all">Positron (Minimal)</option>
                </select>
            </div>

            <div style="margin-top:20px; font-size:0.9em; line-height:1.6;">
                <strong>À propos</strong><br>
                Ce tableau de bord permet l'exploration spatio-temporelle du répertoire lyrique vénitien.<br>
                <br>
                <strong>Données</strong>: <em>sample_operas.geojson</em><br>
                <strong>Technologies</strong>: Leaflet, NoUiSlider<br>
            </div>

            <button class="close-menu" onclick="toggleMenu()">Fermer</button>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.js"></script>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = { min: 1660, max: 1760 };
        
        // Etat Global de l'application
        let state = {
            mode: 'simple', // 'simple' | 'compare'
            currentView: 'operas', // 'operas' | 'entities'
            activeTab: 'A',
            queries: { A: { filters: {}, search: "" }, B: { filters: {}, search: "" } },
            results: { A: [], B: [] },
            range: [1660, 1760],
            data: [],
            isPlaying: false,
            entityFilterIDs: new Set(),
            isEntityFilterActive: false,
        };


        let map, tileLayer, slider, playInterval;
        // Groupes de layers pour gérer l'animation
        let layers = { A: L.layerGroup(), B: L.layerGroup() };
        // Stockage des marqueurs individuels pour update radius (Key = TheatreName)
        let markersRef = { A: {}, B: {} };

        // --- INITIALISATION ---
        document.addEventListener("DOMContentLoaded", () => {
            // 1. Carte
            map = L.map('map', { zoomControl: false }).setView([45.437, 12.335], 14);
            L.control.zoom({ position: 'topright' }).addTo(map);
            
            // Initialisation du fond de carte (vérifie si le dark mode est actif via la checkbox)
            const isDarkInitial = document.body.classList.contains('dark-mode');
            changeMapStyle(isDarkInitial ? 'dark_all' : 'voyager');
            
            layers.A.addTo(map);
            layers.B.addTo(map);

            // 2. Chargement Données
            fetch('sample_operas.geojson')
                .then(r => {
                    if(!r.ok) throw new Error("Fichier non trouvé");
                    return r.json();
                })
                .then(data => {
                    state.data = data.features;
                    initApp();
                })
                .catch(err => {
                    console.error(err);
                    alert("Erreur : sample_operas.geojson introuvable. Vérifiez votre serveur local.");
                });
        });

        let OPERA_METADATA = {};

        // --- NOUVELLE LOGIQUE DE CHARGEMENT DES METADONNÉES D'OPÉRA ---
        function loadOperaMetadata() {
            fetch('sample_operas.geojson')
                .then(response => {
                    if (!response.ok) throw new Error("sample_operas.geojson non trouvé ou illisible.");
                    return response.json();
                })
                .then(geojson => {
                    geojson.features.forEach(feature => {
                        const props = feature.properties;
                        // Index the data by the opera ID
                        OPERA_METADATA[props.id] = {
                            titre: props.titre,
                            annee: props.annee
                        };
                    });
                    console.log("Métadonnées des opéras chargées:", Object.keys(OPERA_METADATA).length);
                })
                .catch(error => {
                    console.error("Erreur lors du chargement des données d'opéras:", error);
                });
        }

        function initApp() {
            // Slider
            slider = noUiSlider.create(document.getElementById('time-slider'), {
                start: [CONFIG.min, CONFIG.max],
                connect: true,
                range: { 'min': CONFIG.min, 'max': CONFIG.max },
                step: 1,
                animate: false
            });
            slider.on('update', (v) => {
                state.range = [Math.round(v[0]), Math.round(v[1])];
                document.getElementById('date-display').innerText = `${state.range[0]} - ${state.range[1]}`;
                updateDashboard();
            });

            // Histogramme (DOM)
            const hContainer = document.getElementById('histogram');
            for(let y=CONFIG.min; y<=CONFIG.max; y++) {
                let d = document.createElement('div');
                d.className = 'hist-col';
                d.id = 'h-'+y;
                d.innerHTML = `<div class="bar-bg"></div><div class="bar-a"></div><div class="bar-b"></div>`;
                hContainer.appendChild(d);
            }

            loadOperaMetadata();

            loadEntitiesData();
            
            // Initialisation de la checkbox du mode sombre dans le menu modal
            document.getElementById('darkModeToggle').checked = document.body.classList.contains('dark-mode');

            renderFacets();
            updateDashboard();
        }



        // LOGIQUE
        function toggleMode() {
            state.mode = document.getElementById('modeToggle').checked ? 'compare' : 'simple';
            document.body.classList.toggle('compare-mode', state.mode === 'compare');
            document.getElementById('legend-b').style.display = state.mode === 'compare' ? 'inline-flex' : 'none';
            
            const tabsContainer = document.querySelector('.tabs-container');
            tabsContainer.style.display = (state.mode === 'compare') ? 'flex' : 'none';

            if(state.mode === 'simple') switchTab('A');
            updateDashboard();
        }

        function updateView() {
            const container = document.getElementById('modeSwitch');
            container.style.display = (state.currentView === 'operas') ? 'flex' : 'none';
        }

        function switchTab(tab) {
            state.activeTab = tab;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab-${tab.toLowerCase()}`).classList.add('active');
            
            // Restaurer la recherche et les facettes
            document.getElementById('searchInput').value = state.queries[tab].search;
            // Correction 1.b: Rafraîchir l'affichage des filtres pour l'onglet actif
            renderFacets(); 
        }

        function handleSearch() {
            state.queries[state.activeTab].search = document.getElementById('searchInput').value.toLowerCase();
            updateDashboard();
        }

        function toggleFilter(key, val, checked) {
            const q = state.queries[state.activeTab];
            if(!q.filters[key]) q.filters[key] = new Set();
            checked ? q.filters[key].add(val) : q.filters[key].delete(val);
            updateDashboard();
        }

        // LOGIQUE DE NAVIGATION DE LA SIDEBAR
        function switchSidebarTab(tabName) {

            // Réinitialiser tous les filtres, modes, etc.
            if (state.currentView === 'entities') {
                document.getElementById('entity-list-view').style.display = 'block';
                document.getElementById('entity-detail-view').style.display = 'none';
            }

            state.currentView = tabName;

            resetCurrent();

            if (state.mode === 'compare') {
                state.mode = 'simple';
                const tabsContainer = document.querySelector('.tabs-container');
                tabsContainer.style.display = 'none';
            }

            state.queries = { A: { filters: {}, search: "" }, B: { filters: {}, search: "" } };
            state.isEntityFilterActive = false;
            state.entityFilterIDs.clear();
            updateView();
            updateDashboard();

            
            // Désactiver tous les onglets de navigation
            document.querySelectorAll('.sidebar-nav .nav-tab').forEach(t => t.classList.remove('active'));
            // Désactiver tous les contenus
            document.querySelectorAll('.filters-wrapper .content-tab').forEach(c => c.classList.remove('active'));

            // Activer l'onglet cliqué
            const activeTab = document.querySelector(`.sidebar-nav .nav-tab[data-content="${tabName}-content"]`);
            if (activeTab) activeTab.classList.add('active');

            // Activer le contenu correspondant
            const activeContent = document.getElementById(`${tabName}-content`);
            if (activeContent) activeContent.classList.add('active');

            // NOUVEAU: Mettre à jour la visibilité de la zone A/B en fonction du mode de comparaison global.
            // Cela s'applique désormais à TOUS les contenus (opéras, entités, etc.)
            const tabsContainer = document.querySelector('.tabs-container');
            tabsContainer.style.display = (state.mode === 'compare') ? 'flex' : 'none';

            // Si on change de contenu, et qu'on est en mode comparaison, on s'assure que le contenu A/B est à jour.
            if (state.mode === 'compare') {
                if (tabName === 'operas') {
                    renderFacets();
                } else if (tabName === 'entities') {
                    // Future fonction pour initialiser/mettre à jour l'affichage des entités A/B
                }
            }
        }

        // Fonction pour gérer les nouveaux accordéons dans Entités ---
        function toggleFacetContent(headerElement) {
            const content = headerElement.nextElementSibling;
            const icon = headerElement.querySelector('i');
            
            // Toggle the open class for display/animation
            content.classList.toggle('open');
            
            // Toggle the arrow icon
            icon.className = content.classList.contains('open') ? 'fas fa-chevron-up' : 'fas fa-chevron-down';
        }

        // --- LOGIQUE D'EXPLORATION DES ENTITÉS ---

        let RAW_ENTITY_DATA = [];

        let ENTITY_DATA = {
            LOC: [],        // Lieux
            COMP_LIBR: [],  // Compositeurs/Librettistes
            THEA: [],       // Théâtres
            ACT: [],        // Acteurs/Actrices
            MISC: []        // Autres
        };

        function loadEntitiesData() {
            fetch('entity_occurrences.json')
                .then(response => {
                    if (!response.ok) throw new Error("entity_occurrences.json non trouvé ou illisible (Statut: " + response.status + ")");
                    return response.json();
                })
                .then(data => {

                    RAW_ENTITY_DATA = data;

                    // Group, count, and store entities by type
                    data.forEach(item => {
                        if (ENTITY_DATA.hasOwnProperty(item.type)) {
                            // Calculate count based on the number of entries (performance IDs)
                            ENTITY_DATA[item.type].push({
                                name: item.entity,
                                type: item.type,
                                count: Object.keys(item.entries).length 
                            });
                        }
                    });

                    // Sort all lists alphabetically by name
                    for (let key in ENTITY_DATA) {
                        ENTITY_DATA[key].sort((a, b) => a.name.localeCompare(b.name));
                    }

                    // Render the lists once the data is ready
                    renderEntitiesTab();
                })
                .catch(error => {
                    console.error("Erreur lors du chargement des données d'entités:", error);
                    // Display a user-friendly error in the Entités panel
                    document.getElementById('entities-content').innerHTML = 
                        `<p style="color: red; padding: 15px;">Erreur de chargement des données: ${error.message}. Vérifiez si le fichier est dans le même dossier.</p>`;
                });
        }


        function renderEntitiesTab() {
            const mapping = {
                'LOC': 'entities-loc-list',
                'COMP_LIBR': 'entities-comp-libr-list',
                'THEA': 'entities-thea-list',
                'ACT': 'entities-act-list',
                'MISC': 'entities-misc-list'
            };

            for (const type in ENTITY_DATA) {
                const listContainer = document.getElementById(mapping[type]);
                if (listContainer) {
                    listContainer.innerHTML = ''; // Clear the "Chargement..." message

                    if (ENTITY_DATA[type].length === 0) {
                        listContainer.innerHTML = `<li class="placeholder-text">Aucune entité de ce type trouvée.</li>`;
                        continue;
                    }

                ENTITY_DATA[type].forEach(entity => {
                    const li = document.createElement('li');
                    li.className = 'entity-item';
                    
                    // NOUVEAU: Ajout de l'événement onclick
                    li.onclick = () => analyseEntity(entity.name, entity.type); // <--- MODIFICATION ICI
                    
                    li.innerHTML = `
                        <span class="entity-name">${entity.name}</span>
                        <span class="entity-count">${entity.count} entrées</span>
                    `;
                    listContainer.appendChild(li);
                });
                }
            }
        }

        // --- LOGIQUE DE VUE DÉTAILLÉE DES ENTITÉS (Fonctions utilitaires) ---

        function showEntityList() {
           // 1. Désactiver le filtre d'entité et vider le Set d'IDs
            state.isEntityFilterActive = false;
            state.entityFilterIDs.clear(); 
            
            // Affiche la liste des entités (vue par défaut)
            document.getElementById('entity-list-view').style.display = 'block';
            document.getElementById('entity-detail-view').style.display = 'none';

            updateDashboard();
        }

        function showEntityDetail() {
            // Affiche la vue détaillée
            document.getElementById('entity-list-view').style.display = 'none';
            document.getElementById('entity-detail-view').style.display = 'block';
        }

        function renderEntryDetail(entries) {
            const listContainer = document.getElementById('detail-entry-list');
            listContainer.innerHTML = '';
            
            // Convert entries object (key=ID, value=Context Array) to a sorted array for display
            const entryIDs = Object.keys(entries).sort((a, b) => parseInt(a) - parseInt(b));

            if (entryIDs.length === 0) {
                listContainer.innerHTML = `<p class="placeholder-text">Aucune entrée contextuelle trouvée pour cette entité.</p>`;
                return;
            }

            entryIDs.forEach(id => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'entry-item';

                // NOUVEAU: Récupération des métadonnées de l'opéra
                const opera = OPERA_METADATA[id];
                let operaDisplay = `Entrée ID: ${id} (Métadonnées non trouvées)`; // Fallback en cas d'erreur de correspondance

                if (opera) {
                    // Affichage formaté: Titre de l'opéra (Année)
                    operaDisplay = `${opera.titre} (${opera.annee})`;
                }


                // Map the context sentences array to HTML divs
                let contextHTML = entries[id].map(sentence => 
                    `<div class="entry-context">- ${sentence}</div>`
                ).join('');

                itemDiv.innerHTML = `
                    <div class="entry-id">${operaDisplay}</div>
                    ${contextHTML}
                `;
                
                listContainer.appendChild(itemDiv);
            });
        }

        function analyseEntity(entityName, entityType) {
            // 1. Trouver l'objet entité complet à partir du nom
            const entity = RAW_ENTITY_DATA.find(e => e.entity === entityName && e.type === entityType);

            if (!entity || !entity.entries) {
                console.error("Données d'entité introuvables ou entrées manquantes:", entityName);
                return;
            }

            // 2. Extraire les IDs de l'entité et les convertir en entiers pour la comparaison
            const entryIDs = Object.keys(entity.entries);
            state.entityFilterIDs = new Set(entryIDs.map(id => parseInt(id))); 
            state.isEntityFilterActive = true;

            // 3. Mettre à jour le titre de la vue détaillée
            document.getElementById('detail-entity-name').textContent = `${entityName}`;

            // 4. Rendre les détails des entrées
            renderEntryDetail(entity.entries);

            // 5. Changer la vue
            showEntityDetail();

            updateDashboard();
        }

        // --- MOTEUR DE RENDU ---
        function updateDashboard() {
            // 1. Calculer les résultats
            state.results.A = filterData(state.queries.A);
            state.results.B = state.mode === 'compare' ? filterData(state.queries.B) : [];

            // 2. Mettre à jour la Carte (Animation)
            updateMapLayer('A', state.results.A, '#9e2a2b');
            updateMapLayer('B', state.results.B, '#219ebc');

            // 3. Histogramme
            updateHistogram();

            // 4. Compteurs
            document.getElementById('count-a').innerText = state.results.A.length;
            document.getElementById('count-b').innerText = state.results.B.length;
        }

        function filterData(q) {
            const [s, e] = state.range;

            if (!state.data) return [];

            return state.data.filter(f => {
                const p = f.properties;

                if (state.isEntityFilterActive) {
                    // L'opéra doit faire partie des IDs (p.id) stockés par l'entité cliquée
                    // Note: p.id est supposé être un nombre, state.entityFilterIDs contient des nombres.
                    if (!state.entityFilterIDs.has(p.id)) {
                        return false;
                    }
                }

                // Temps
                if(p.annee < s || p.annee > e) return false;
                
                // Recherche (CORRECTION 1.a: Ajout de la recherche sur theatre et compositeur)
                if(q.search) {
                    const txt = (p.titre + " " + (p.theatre || '') + " " + (p.compositeur || '')).toLowerCase();
                    if(!txt.includes(q.search.toLowerCase())) return false;
                }
                
                // Facettes
                for(let k in q.filters) {
                    // Utilise .has() pour vérifier l'existence dans le Set des filtres actifs
                    if(q.filters[k].size > 0 && !q.filters[k].has(p[k])) return false;
                }
                return true;
            });
        }

        // --- VISUALISATION (CARTE & ANIMATION) ---
        function updateMapLayer(layerKey, dataset, color) {
            const group = layers[layerKey];
            const refs = markersRef[layerKey];
            
            // Agrégation
            let venues = {};
            // Initialiser tous les théâtres connus à 0 pour permettre le rétrécissement
            Object.keys(refs).forEach(k => {
                // S'assurer que le marqueur est toujours sur la carte même avec count 0 pour l'animation
                venues[k] = {count:0, coords: refs[k].getLatLng(), list:[]};
                // Si count est 0, on met le rayon à 0 pour l'animation de rétrécissement
                refs[k].setRadius(0);
            });

            dataset.forEach(f => {
                let t = f.properties.theatre;
                if(!venues[t]) venues[t] = { count:0, coords: [f.geometry.coordinates[1], f.geometry.coordinates[0]], list:[] };
                venues[t].count++;
                venues[t].list.push(f.properties);
            });

            // Dessin / Mise à jour
            Object.keys(venues).forEach(key => {
                let v = venues[key];
                let r = v.count > 0 ? Math.sqrt(v.count) * 6 + 2 : 0; // Rayon cible

                if (refs[key]) {
                    // Le marqueur existe, on change son rayon (CSS transition fera le reste)
                    refs[key].setRadius(r);
                    if(v.count > 0) refs[key].bindPopup(buildPopup(key, v));
                } else if (v.count > 0) {
                    // Création
                    let m = L.circleMarker(v.coords, {
                        radius: 0, color: color, fillColor: color, fillOpacity: 0.6, weight: 1
                    });
                    m.bindPopup(buildPopup(key, v));
                    m.addTo(group);
                    refs[key] = m;
                    setTimeout(() => m.setRadius(r), 10); // Animation entrée
                }
            });
            
            // S'assurer que les marqueurs sans données sont retirés de la carte pour éviter les résidus
            Object.keys(refs).forEach(k => {
                if(!venues[k] && refs[k]) {
                    group.removeLayer(refs[k]);
                    delete refs[k];
                }
            });
        }

        function buildPopup(title, data) {
            let html = `<strong>${title}</strong><br>${data.count} opéras<br><hr style="margin:5px 0; border:0; border-top:1px solid #eee">`;
            data.list.slice(0,5).forEach(o => html += `<div style="font-size:0.9em">${o.annee}: ${o.titre}</div>`);
            if(data.list.length > 5) html += `<em>...et ${data.list.length-5} autres</em>`;
            return html;
        }

        // --- HISTOGRAMME ---
        function updateHistogram() {
            // Echelle Globale
            // NOTE: The globalCounts and max calculation MUST be based on the ENTIRE dataset 
            // for the gray background bars to represent the total density.
            let globalCounts = {}, max = 0;
            
            // Assuming state.data is the full, unfiltered list of features
            state.data.forEach(f => {
                globalCounts[f.properties.annee] = (globalCounts[f.properties.annee]||0)+1;
                if(globalCounts[f.properties.annee] > max) max = globalCounts[f.properties.annee];
            });


            // NOUVEAU: getDist prend maintenant les résultats filtrés (déjà calculés dans updateDashboard)
            const getDist = (results) => {
                let c = {};
                // Nous itérons sur les résultats déjà filtrés (results)
                results.forEach(f => c[f.properties.annee] = (c[f.properties.annee]||0)+1);
                return c;
            };

            // MODIFICATION CRITIQUE: Utiliser state.results.A et state.results.B
            // Ces variables contiennent les données filtrées par filterData(), y compris le filtre Entité
            let cA = getDist(state.results.A);
            let cB = state.mode === 'compare' ? getDist(state.results.B) : {};

            for(let y=CONFIG.min; y<=CONFIG.max; y++) {
                let el = document.getElementById('h-'+y);

                if (!el) continue; // added
                
                let hBg = max ? (globalCounts[y]||0)/max*100 : 0;
                let hA  = max ? (cA[y]||0)/max*100 : 0;
                let hB  = max ? (cB[y]||0)/max*100 : 0;
                
                // MÀJ des hauteurs
                el.querySelector('.bar-bg').style.height = hBg+'%';
                el.querySelector('.bar-a').style.height = hA+'%';
                el.querySelector('.bar-b').style.height = hB+'%';
                
                // Griser hors période
                el.style.opacity = (y >= state.range[0] && y <= state.range[1]) ? 1 : 0.3;
            }
        }

        // --- UI GENERATION ---
        const FACETS = [
            {key:'theatre', label:'Théâtres'}, 
            {key:'compositeur', label:'Compositeurs'}, 
            {key:'librettiste', label:'Librettistes'}
        ];

        function renderFacets() {
            const container = document.getElementById('facets-output');
            container.innerHTML = '';
            
            const q = state.queries[state.activeTab];

            FACETS.forEach(facet => {
                // Comptes (Comptes globaux, ou on pourrait faire les comptes selon la recherche active - ici: global)
                let counts = {};
                state.data.forEach(f => {
                    let v = f.properties[facet.key];
                    if(v) counts[v] = (counts[v]||0)+1;
                });

                let group = document.createElement('div');
                group.className = 'facet-group';
                
                // Header
                let header = document.createElement('div');
                header.className = 'facet-header';
                header.innerHTML = `<span>${facet.label}</span> <i class="fas fa-chevron-down"></i>`;
                
                // Content
                let content = document.createElement('div');
                content.className = 'facet-content';
                
                header.onclick = () => {
                    content.classList.toggle('open');
                    header.querySelector('i').className = content.classList.contains('open') ? 'fas fa-chevron-up' : 'fas fa-chevron-down';
                };

                Object.keys(counts).sort().forEach(val => {
                    let checked = q.filters[facet.key] && q.filters[facet.key].has(val);
                    let row = document.createElement('div');
                    row.className = 'checkbox-item';
                    row.innerHTML = `
                        <div style="display:flex; align-items:center">
                            <input type="checkbox" ${checked?'checked':''} style="margin-right:8px"> ${val}
                        </div>
                        <span class="count-badge">${counts[val]}</span>
                    `;
                    row.querySelector('input').onchange = (e) => toggleFilter(facet.key, val, e.target.checked);
                    content.appendChild(row);
                });

                group.appendChild(header);
                group.appendChild(content);
                container.appendChild(group);
            });
        }

        // --- OUTILS ---
        function resetCurrent() {
            state.queries[state.activeTab] = { filters: {}, search: "" };
            // Correction 1.a: Réinitialiser l'input de recherche et rafraîchir les facettes
            document.getElementById('searchInput').value = "";
            renderFacets(); 
            updateDashboard();
        }

        function exportData() {
            // Export des données actives (A si simple, ou A+B si compare? faisons Simple: exporte la vue active)
            let dataToExport = state.results[state.activeTab];
            if(!dataToExport.length) return alert("Aucune donnée visible.");
            
            let keys = Object.keys(dataToExport[0].properties);
            let csv = keys.join(",") + "\n";
            dataToExport.forEach(f => {
                csv += keys.map(k => `"${(f.properties[k]||"").toString().replace(/"/g, '""')}"`).join(",") + "\n";
            });
            
            let link = document.createElement("a");
            link.href = "data:text/csv;charset=utf-8," + encodeURI(csv);
            link.download = `opera_export_${state.activeTab}.csv`;
            link.click();
        }

        function toggleMenu() {
            let el = document.getElementById('menu-overlay');
            el.style.display = (el.style.display === 'flex') ? 'none' : 'flex';
        }

        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            let isDark = document.body.classList.contains('dark-mode');
            // Met à jour l'état de la checkbox dans le modal
            document.getElementById('darkModeToggle').checked = isDark; 
            changeMapStyle(isDark ? 'dark_all' : 'voyager');
        }

        function changeMapStyle(style) {
            if(tileLayer) map.removeLayer(tileLayer);
            tileLayer = L.tileLayer(`https://{s}.basemaps.cartocdn.com/rastertiles/${style}/{z}/{x}/{y}{r}.png`, {
                attribution: '&copy; CARTO'
            }).addTo(map);
            // layers.A.bringToFront(); layers.B.bringToFront();
        }

        function togglePlay() {
            state.isPlaying = !state.isPlaying;
            let btn = document.getElementById('play-icon');
            btn.className = state.isPlaying ? "fas fa-pause" : "fas fa-play";
            
            if(state.isPlaying) {
                let span = state.range[1] - state.range[0];
                let cur = state.range[0];
                playInterval = setInterval(() => {
                    cur++;
                    // Si l'année de fin de la fenêtre glissante dépasse la limite max
                    if(cur + span > CONFIG.max) {
                        togglePlay(); // Arrête la lecture
                        return;
                    }
                    slider.set([cur, cur+span]);
                }, 800);
            } else {
                clearInterval(playInterval);
            }
        }
    </script>
</body>
</html>