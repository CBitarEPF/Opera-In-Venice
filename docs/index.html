<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Opera in Venice: Comparative Analytics</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Palette Sémantique */
            --primary: #9e2a2b;      /* Recherche A (Rouge historique) */
            --secondary: #219ebc;    /* Recherche B (Bleu analytique) */
            --gold: #e09f3e;
            
            /* UI Variables */
            --bg-panel: #ffffff;
            --bg-map: #e5e5e5;
            --text-main: #2b2d42;
            --border: #e9ecef;
            --bar-bg: #dcdcdc;
        }

        /* Dark Mode */
        body.dark-mode {
            --bg-panel: #1a1a1a;
            --bg-map: #121212;
            --text-main: #e0e0e0;
            --border: #333;
            --bar-bg: #333;
        }

        body {
            margin: 0; padding: 0;
            font-family: 'Lato', sans-serif;
            color: var(--text-main);
            background: var(--bg-panel);
            display: grid;
            height: 100vh; width: 100vw;
            grid-template-columns: 340px 1fr; 
            grid-template-rows: 1fr 150px;
            grid-template-areas: "sidebar map" "sidebar timeline";
            overflow: hidden;
            transition: background 0.3s, color 0.3s;
        }

        /* --- 1. SIDEBAR --- */
        #sidebar {
            grid-area: sidebar;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex; flex-direction: column;
            box-shadow: 4px 0 15px rgba(0,0,0,0.05);
            z-index: 2000;
        }

        .sidebar-header {
            padding: 20px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--gold);
        }

        .header-top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .app-title { font-family: 'Playfair Display', serif; font-size: 22px; margin: 0; color: var(--primary); }
        .burger-btn { background: none; border: none; font-size: 20px; color: var(--text-main); cursor: pointer; }

        /* Switch Mode Comparaison */
        .mode-switch-container {
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(0,0,0,0.03); padding: 10px; border-radius: 6px;
        }
        .switch-label { font-size: 0.9em; font-weight: bold; display: flex; align-items: center; gap: 8px; }
        
        /* Toggle Switch CSS */
        .switch { position: relative; display: inline-block; width: 36px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider-round { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider-round:before { position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider-round { background-color: var(--secondary); }
        input:checked + .slider-round:before { transform: translateX(16px); }

        /* Onglets A/B */
        .tabs-container { display: none; border-bottom: 1px solid var(--border); }
        body.compare-mode .tabs-container { display: flex; }
        .tab { flex: 1; padding: 12px; text-align: center; cursor: pointer; font-weight: bold; font-size: 0.9em; border-bottom: 3px solid transparent; opacity: 0.6; transition: 0.3s; }
        .tab:hover { opacity: 1; background: rgba(0,0,0,0.02); }
        .tab.active { opacity: 1; border-bottom-color: currentColor; }
        .tab-a.active { color: var(--primary); background: rgba(158, 42, 43, 0.05); }
        .tab-b.active { color: var(--secondary); background: rgba(51, 92, 103, 0.05); }

        /* Zone Filtres */
        .filters-wrapper { flex-grow: 1; overflow-y: auto; padding: 0 20px; }
        
        .search-box { margin: 15px 0; }
        .search-input { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; background: var(--bg-panel); color: var(--text-main); box-sizing: border-box; }

        /* Accordéons Facettes */
        .facet-group { border-bottom: 1px solid var(--border); padding: 15px 0; }
        .facet-header { display: flex; justify-content: space-between; cursor: pointer; font-weight: 700; color: #666; text-transform: uppercase; font-size: 11px; letter-spacing: 1px; }
        .facet-header:hover { color: var(--primary); }
        .facet-content { margin-top: 10px; display: none; max-height: 250px; overflow-y: auto; }
        .facet-content.open { display: block; animation: fadeIn 0.3s; }
        
        .checkbox-item { display: flex; justify-content: space-between; align-items: center; padding: 4px 0; font-size: 13px; cursor: pointer; }
        .count-badge { background: rgba(0,0,0,0.05); padding: 2px 6px; border-radius: 4px; font-size: 10px; }

        .sidebar-footer { padding: 15px 20px; border-top: 1px solid var(--border); display: flex; gap: 10px; }
        .btn { flex: 1; padding: 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; text-transform: uppercase; }
        .btn-reset { background: #f0f0f0; color: #333; }
        .btn-export { background: var(--text-main); color: #fff; }

        /* New: Menu Tabs for Sidebar Navigation */
        .sidebar-nav {
            display: flex;
            border-bottom: 1px solid var(--border);
            background: rgba(0,0,0,0.03); /* Lighter background for the menu bar */
        }
        body.dark-mode .sidebar-nav {
            background: rgba(255,255,255,0.05); 
        }

        .nav-tab {
            flex: 1;
            padding: 12px 10px;
            text-align: center;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.95em;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: 0.3s;
        }
        .nav-tab:hover {
            color: var(--primary);
            background: rgba(0,0,0,0.01);
        }
        .nav-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: var(--bg-panel); /* Active tab matches panel background */
        }

        /* Adjust the filters wrapper to handle the new content structure */
        .filters-wrapper { 
            flex-grow: 1; 
            overflow-y: auto; 
            /* Remove padding here, we'll put it inside the content-tab */
            padding: 0; 
        }

        /* New: Content area for each tab */
        .content-tab {
            padding: 0 20px; /* Add back the padding only to the content area */
            display: none;
            height: 100%; /* Ensure content fills the wrapper */
        }
        .content-tab.active {
            display: block;
        }

        /* --- New Styles for Entity Lists --- */
        .entity-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        .entity-item {
            padding: 6px 0;
            cursor: pointer;
            border-bottom: 1px dotted var(--border);
            transition: 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
        }
        .entity-item:last-child {
            border-bottom: none;
        }
        .entity-item:hover {
            background: rgba(var(--primary-rgb), 0.05); /* Use RGB variable if defined, otherwise use a fixed color */
            background: rgba(0,0,0,0.05); 
        }
        .entity-name {
            font-weight: 500;
        }
        .entity-count {
            font-size: 0.8em;
            color: #999;
            background: var(--border);
            padding: 2px 5px;
            border-radius: 3px;
        }
        .placeholder-text {
            padding: 10px 0;
            font-style: italic;
            color: #999;
            text-align: center;
        }

        .detail-title {
            font-family: 'Playfair Display', serif;
            font-size: 1.5em;
            margin-top: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--border);
            padding-bottom: 5px;
        }
        .back-button {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            margin-bottom: 15px;
            transition: 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .back-button:hover {
            background: var(--border);
        }
        .entry-item {
            padding: 10px 0;
            border-bottom: 1px dashed var(--border);
        }
        .entry-item:last-child {
            border-bottom: none;
        }
        .entry-id {
            font-weight: bold;
            color: var(--primary); /* Uses the active primary color */
            margin-bottom: 5px;
        }
        .entry-context {
            font-size: 0.85em;
            line-height: 1.4;
            padding-left: 10px;
            border-left: 2px solid #ccc;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        body.dark-mode .entry-context {
            border-left-color: #555;
        }

        /* --- 2. MAP --- */
        #map { grid-area: map; background: var(--bg-map); z-index: 1; }
        /* Animation fluide des cercles */
        .leaflet-interactive { mix-blend-mode: multiply; transition: r 0.6s cubic-bezier(0.25, 0.8, 0.25, 1), fill-opacity 0.3s; }
        /* En Dark Mode, multiply ne marche pas bien, on utilise screen ou normal */
        body.dark-mode .leaflet-interactive { mix-blend-mode: screen; }

        /* --- 3. TIMELINE --- */
        #timeline-panel {
            grid-area: timeline; background: var(--bg-panel); border-top: 1px solid var(--border);
            padding: 10px 40px; display: flex; flex-direction: column; position: relative; z-index: 1000;
        }

        .controls-row { display: flex; align-items: center; margin-bottom: 5px; }
        .play-btn { 
            width: 36px; height: 36px; border-radius: 50%; border: 2px solid var(--primary); color: var(--primary);
            background: none; cursor: pointer; margin-right: 20px; display: flex; justify-content: center; align-items: center; transition: 0.2s;
        }
        .play-btn:hover { background: var(--primary); color: white; }
        
        .date-display { font-family: 'Playfair Display'; font-size: 1.3em; font-weight: bold; margin-right: 30px; }
        .legend-item { display: inline-flex; align-items: center; gap: 6px; font-size: 0.9em; font-weight: bold; margin-right: 20px; }

        /* Histogramme Stacked */
        #histogram { flex-grow: 1; width: 100%; display: flex; align-items: flex-end; margin-bottom: 5px; height: 60px; }
        .hist-col { flex: 1; height: 100%; margin: 0 1px; position: relative; display: flex; flex-direction: column-reverse; }
        .bar-bg { position: absolute; bottom:0; width:100%; background: var(--bar-bg); z-index:0; transition: height 0.3s; }
        .bar-a { width: 100%; background: var(--primary); opacity: 0.7; z-index: 2; transition: height 0.3s; }
        .bar-b { width: 100%; background: var(--secondary); opacity: 0.7; z-index: 1; transition: height 0.3s; display: none; }
        body.compare-mode .bar-b { display: block; }

        /* Slider */
        #time-slider { height: 6px; border: none; background: transparent; }
        .noUi-connect { background: #666; opacity: 0.3; }
        .noUi-handle { width: 14px; height: 14px; border-radius: 50%; background: #444; border: 2px solid #fff; top: -4px; right: -7px; cursor: grab; box-shadow: none; }

        /* --- MENU BURGER (MODAL) --- */
        #menu-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.5); z-index: 5000; display: none;
            justify-content: center; align-items: center; backdrop-filter: blur(3px);
        }
        #menu-box {
            background: var(--bg-panel); width: 400px; max-width: 90%; padding: 30px;
            border-radius: 8px; box-shadow: 0 20px 50px rgba(0,0,0,0.3);
        }
        #menu-box h2 { margin-top: 0; font-family: 'Playfair Display'; color: var(--primary); border-bottom: 1px solid var(--gold); padding-bottom: 10px;}
        .menu-row { display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid var(--border); }
        .close-menu { width: 100%; padding: 12px; background: var(--text-main); color: var(--bg-panel); border: none; cursor: pointer; margin-top: 20px; font-weight: bold; text-transform: uppercase; }

        /* Boutons d'export : Style élégant et intégré */
        .rec-btn, .snap-btn {
            width: 36px; height: 36px; border-radius: 50%; border: 1px solid var(--border); 
            background: transparent; color: var(--text-main);
            cursor: pointer; margin-right: 10px; display: flex; 
            justify-content: center; align-items: center; transition: all 0.2s ease;
        }

        .snap-btn:hover { background: var(--text-main); color: var(--bg-panel); }

        /* Le bouton REC devient rouge uniquement à l'enregistrement ou au survol */
        .rec-btn:hover { color: var(--primary); border-color: var(--primary); }
        .rec-btn.recording { 
            background: var(--primary); color: white; border-color: var(--primary);
            animation: pulse 1.5s infinite; pointer-events: none;
        }

        @keyframes pulse { 
            0% { box-shadow: 0 0 0 0 rgba(158, 42, 43, 0.7); } /* utilise la couleur primary */
            70% { box-shadow: 0 0 0 10px rgba(158, 42, 43, 0); }
            100% { box-shadow: 0 0 0 0 rgba(158, 42, 43, 0); }
        }
        /* Animation Helper */
        @keyframes fadeIn { from { opacity:0; transform: translateY(-5px);} to { opacity:1; transform: translateY(0);} }

        /* --- FEATURE B: Tooltip Histogramme --- */
        #hist-tooltip {
            position: fixed;
            background: rgba(43, 45, 66, 0.95);
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.85em;
            pointer-events: none; /* La souris passe au travers */
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 5000;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            border: 1px solid var(--gold);
            white-space: nowrap;
        }

        /* --- FEATURE C: Visite Guidée (Tour Box) --- */
        #tour-overlay {
            position: absolute;
            bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 600px; max-width: 90%;
            background: var(--bg-panel);
            border-left: 5px solid var(--primary);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 20px;
            border-radius: 4px;
            z-index: 4000; /* Au-dessus de la carte */
            display: none; /* Caché par défaut */
            font-family: 'Lato', sans-serif;
            animation: slideUp 0.4s ease-out;
        }
        #tour-overlay h3 { margin: 0 0 10px 0; font-family: 'Playfair Display'; color: var(--primary); }
        #tour-overlay p { margin: 0 0 20px 0; line-height: 1.5; font-size: 0.95em; color: var(--text-main); }
        .tour-controls { display: flex; justify-content: flex-end; gap: 10px; }

        @keyframes slideUp { from { transform: translate(-50%, 20px); opacity: 0; } to { transform: translate(-50%, 0); opacity: 1; } }
    </style>
</head>
<body>

    <div id="sidebar">
        <div class="sidebar-header">
            <div class="header-top">
                <h1 class="app-title">Opera in Venice</h1>
                <button class="burger-btn" onclick="toggleMenu()"><i class="fas fa-bars"></i></button>
            </div>

            <!-- Toggle Heatmap -->
            <div class="mode-switch-container" style="margin-top: 10px;">
                <div class="switch-label"><i class="fas fa-fire-alt"></i> Heatmap mode</div>
                <label class="switch">
                    <input type="checkbox" id="heatmapToggle" onchange="toggleHeatmap()">
                    <span class="slider-round"></span>
                </label>
            </div>

            <div class="mode-switch-container" id = "modeSwitch">
                <div class="switch-label"><i class="fas fa-balance-scale"></i> Comparison mode</div>
                <label class="switch">
                    <input type="checkbox" id="modeToggle" onchange="toggleMode()">
                    <span class="slider-round"></span>
                </label>
            </div>
        </div>

        <div class="tabs-container">
            <div class="tab tab-a active" onclick="switchTab('A')">Search A</div>
            <div class="tab tab-b" onclick="switchTab('B')">Search B</div>
        </div>

        <div class="sidebar-nav">
            <div class="nav-tab active" data-content="operas-content" onclick="switchSidebarTab('operas')">Opéras</div>
            <div class="nav-tab" data-content="entities-content" onclick="switchSidebarTab('entities')">Entités</div>
        </div>

        <div class="filters-wrapper">
        
            <div id="operas-content" class="content-tab active">
                <div class="search-box">
                    <input type="text" id="searchInput" class="search-input" placeholder="Search (Title, Theater, Composer)..." onkeyup="handleSearch()">
                </div>
                
                <div id="facets-output">Loading...</div>
            </div>
        <div id="entities-content" class="content-tab">
            
            <div id="entity-list-view">
                <p style="margin: 15px 0 10px; font-size:0.9em; font-style: italic; color:#888;">Select one entity below. Numbers show how many references stay in the corpus.</p>

                <div class="facet-group">
                    <div class="facet-header" onclick="toggleFacetContent(this)">
                        <span>Places</span> 
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="facet-content">
                        <ul id="entities-loc-list" class="entity-list">
                            <li class="placeholder-text">Loading entities...</li>
                        </ul> 
                    </div>
                </div>

                <div class="facet-group">
                    <div class="facet-header" onclick="toggleFacetContent(this)">
                        <span>Composers/Writters</span> 
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="facet-content">
                        <ul id="entities-comp-libr-list" class="entity-list">
                            <li class="placeholder-text">Loading entities...</li>
                        </ul>
                    </div>
                </div>

                <div class="facet-group">
                    <div class="facet-header" onclick="toggleFacetContent(this)">
                        <span>Theaters</span> 
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="facet-content">
                        <ul id="entities-thea-list" class="entity-list">
                            <li class="placeholder-text">Chargement des entités...</li>
                        </ul>
                    </div>
                </div>

                <div class="facet-group">
                    <div class="facet-header" onclick="toggleFacetContent(this)">
                        <span>Singers</span> 
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="facet-content">
                        <ul id="entities-act-list" class="entity-list">
                            <li class="placeholder-text">Loading entities...</li>
                        </ul>
                    </div>
                </div>

                <div class="facet-group">
                    <div class="facet-header" onclick="toggleFacetContent(this)">
                        <span>Others</span> 
                        <i class="fas fa-chevron-down"></i>
                    </div>
                    <div class="facet-content">
                        <ul id="entities-misc-list" class="entity-list">
                            <li class="placeholder-text">Loading entities...</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div id="entity-detail-view" style="display:none;">
                <div style="padding: 10px 20px;">
                    <button class="back-button" onclick="showEntityList()">
                        <i class="fas fa-chevron-left"></i> Back to the list
                    </button>
                    <h3 id="detail-entity-name" class="detail-title"></h3>
                    <div id="detail-entry-list">
                        </div>
                </div>
            </div>

        </div>
        </div>

        <div class="sidebar-footer">
            <button class="btn btn-reset" onclick="resetCurrent()"><i class="fas fa-undo"></i> Reset</button>
            <button class="btn" style="background: var(--gold); color: white;" onclick="startTour()"><i class="fas fa-route"></i> Visite</button>
            <button class="btn btn-export" onclick="exportData()"><i class="fas fa-file-csv"></i> Export</button>
        </div>
    </div>

    <div id="map"></div>

    <div id="timeline-panel">
        <div class="controls-row">
            <button class="play-btn" onclick="togglePlay()"><i id="play-icon" class="fas fa-play"></i></button>
            
            <button class="snap-btn" onclick="takeScreenshot()" title="Capture d'écran (PNG)"><i class="fas fa-camera"></i></button>
            <button class="rec-btn" id="rec-btn" onclick="toggleRecording()" title="Enregistrer Animation (GIF)"><i class="fas fa-video"></i></button>
            
            <div class="date-display" id="date-display">1660 - 1760</div>
            
            <div class="legend-item" style="color:var(--primary)">
                <i class="fas fa-circle"></i> <span id="count-a">0</span>
            </div>
            <div class="legend-item" id="legend-b" style="color:var(--secondary); display:none;">
                <i class="fas fa-circle"></i> <span id="count-b">0</span>
            </div>
        </div>

        <div id="histogram"></div>
        <div id="time-slider"></div>
    </div>

    <div id="menu-overlay" onclick="if(event.target==this) toggleMenu()">
        <div id="menu-box">
            <h2>Settings & Information</h2>
            
            <div class="menu-row">
                <span><i class="fas fa-moon"></i> Dark Mode</span>
                <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()">
            </div>

            <div class="menu-row">
                <span><i class="fas fa-map"></i> Map</span>
                <select id="mapStyle" onchange="changeMapStyle(this.value)" style="padding:5px;">
                    <option value="voyager">Light Mode</option>
                    <option value="dark_all">Dark Mode</option>
                    <option value="light_all">Minimal Mode</option>
                </select>
            </div>

            <div style="margin-top:20px; font-size:0.9em; line-height:1.6;">
                <strong>À propos</strong><br>
                Ce tableau de bord permet l'exploration spatio-temporelle du répertoire lyrique vénitien.<br>
                <br>
                <strong>Data</strong>: Eleanor Selfridge-Field, <em>A New Chronology of Venetian Opera and Related Genres : 1660-1760</em>, Stanford, Stanford University Press, 2007.<br>
                <strong>Technologies</strong>: Leaflet, NoUiSlider<br>
            </div>

            <button class="close-menu" onclick="toggleMenu()">Close</button>
        </div>
    </div>

    <!-- Feature B: Tooltip container -->
    <div id="hist-tooltip"></div>

    <!-- Feature C: Boîte de la visite guidée -->
    <div id="tour-overlay">
        <h3 id="tour-title">Titre de l'étape</h3>
        <p id="tour-text">Contenu explicatif...</p>
        <div class="tour-controls">
            <button class="btn btn-reset" onclick="endTour()">Quitter</button>
            <button class="btn btn-export" onclick="nextTourStep()">Suivant <i class="fas fa-chevron-right"></i></button>
        </div>
    </div>

    <div id="export-overlay" style="display:none;">
            <i class="fas fa-spinner fa-spin fa-3x"></i>
            <div id="export-status">Génération du GIF en cours...</div>
    </div>

    <!-- Bibliothèques pour Capture et GIF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.js"></script>
    <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = { min: 1660, max: 1760 };
        
        // Etat Global de l'application
        let state = {
            mode: 'simple', // 'simple' | 'compare'
            currentView: 'operas', // 'operas' | 'entities'
            activeTab: 'A',
            queries: { A: { filters: {}, search: "" }, B: { filters: {}, search: "" } },
            results: { A: [], B: [] },
            range: [1660, 1760],
            data: [],
            isPlaying: false,
            entityFilterIDs: new Set(),
            isEntityFilterActive: false,
            vizMode: 'points',
            isRecording: false
        };

        let heatLayer = null;


        let map, tileLayer, slider, playInterval;
        // Groupes de layers pour gérer l'animation
        let layers = { A: L.layerGroup(), B: L.layerGroup() };
        // Stockage des marqueurs individuels pour update radius (Key = TheatreName)
        let markersRef = { A: {}, B: {} };

        // --- INITIALISATION ---
        document.addEventListener("DOMContentLoaded", () => {
            // 1. Carte
            map = L.map('map', { zoomControl: false, preferCanvas: true }).setView([45.437, 12.335], 14);
            L.control.zoom({ position: 'topright' }).addTo(map);
            
            // Initialisation du fond de carte (vérifie si le dark mode est actif via la checkbox)
            const isDarkInitial = document.body.classList.contains('dark-mode');
            changeMapStyle(isDarkInitial ? 'dark_all' : 'voyager');
            
            layers.A.addTo(map);
            layers.B.addTo(map);

            // 2. Chargement Données
            fetch('database_operas.geojson')
                .then(r => {
                    if(!r.ok) throw new Error("File not found");
                    return r.json();
                })
                .then(data => {
                    state.data = data.features;
                    initApp();
                })
                .catch(err => {
                    console.error(err);
                    alert("Error: database_operas.geojson not found. Check your local server.");
                });
        });

        let OPERA_METADATA = {};

        // --- NOUVELLE LOGIQUE DE CHARGEMENT DES METADONNÉES D'OPÉRA ---
        function loadOperaMetadata() {
            fetch('database_operas.geojson')
                .then(response => {
                    if (!response.ok) throw new Error("database_operas.geojson not found or not readable.");
                    return response.json();
                })
                .then(geojson => {
                    geojson.features.forEach(feature => {
                        const props = feature.properties;
                        // Index the data by the opera ID
                        OPERA_METADATA[props.id] = {
                            titre: props.titre,
                            annee: props.annee
                        };
                    });
                    console.log("Operas metadata loaded:", Object.keys(OPERA_METADATA).length);
                })
                .catch(error => {
                    console.error("Error when loading operas data:", error);
                });
        }

        function initApp() {
            // Slider
            slider = noUiSlider.create(document.getElementById('time-slider'), {
                start: [CONFIG.min, CONFIG.max],
                connect: true,
                range: { 'min': CONFIG.min, 'max': CONFIG.max },
                step: 1,
                animate: false
            });
            slider.on('update', (v) => {
                state.range = [Math.round(v[0]), Math.round(v[1])];
                document.getElementById('date-display').innerText = `${state.range[0]} - ${state.range[1]}`;
                updateDashboard();
            });

            // Histogramme (DOM)
            const hContainer = document.getElementById('histogram');
            for(let y=CONFIG.min; y<=CONFIG.max; y++) {
                let d = document.createElement('div');
                d.className = 'hist-col';
                d.id = 'h-'+y;
                d.innerHTML = `<div class="bar-bg"></div><div class="bar-a"></div><div class="bar-b"></div>`;
                hContainer.appendChild(d);
            }

            loadOperaMetadata();

            loadEntitiesData();
            
            // Initialisation de la checkbox du mode sombre dans le menu modal
            document.getElementById('darkModeToggle').checked = document.body.classList.contains('dark-mode');

            renderFacets();
            updateDashboard();
        }



        // LOGIQUE
        function toggleMode() {
            state.mode = document.getElementById('modeToggle').checked ? 'compare' : 'simple';
            document.body.classList.toggle('compare-mode', state.mode === 'compare');
            document.getElementById('legend-b').style.display = state.mode === 'compare' ? 'inline-flex' : 'none';
            
            const tabsContainer = document.querySelector('.tabs-container');
            tabsContainer.style.display = (state.mode === 'compare') ? 'flex' : 'none';

            if(state.mode === 'simple') switchTab('A');
            updateDashboard();
        }

        function updateView() {
            const container = document.getElementById('modeSwitch');
            container.style.display = (state.currentView === 'operas') ? 'flex' : 'none';
        }

        function switchTab(tab) {
            state.activeTab = tab;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab-${tab.toLowerCase()}`).classList.add('active');
            
            // Restaurer la recherche et les facettes
            document.getElementById('searchInput').value = state.queries[tab].search;
            // Correction 1.b: Rafraîchir l'affichage des filtres pour l'onglet actif
            renderFacets(); 
        }

        function handleSearch() {
            state.queries[state.activeTab].search = document.getElementById('searchInput').value.toLowerCase();
            updateDashboard();
        }

        function toggleFilter(key, val, checked) {
            const q = state.queries[state.activeTab];
            if(!q.filters[key]) q.filters[key] = new Set();
            checked ? q.filters[key].add(val) : q.filters[key].delete(val);
            updateDashboard();
        }

        // LOGIQUE DE NAVIGATION DE LA SIDEBAR
        function switchSidebarTab(tabName) {

            // Réinitialiser tous les filtres, modes, etc.
            if (state.currentView === 'entities') {
                document.getElementById('entity-list-view').style.display = 'block';
                document.getElementById('entity-detail-view').style.display = 'none';
            }

            state.currentView = tabName;

            resetCurrent();

            // if (state.mode === 'compare') {
            //     state.mode = 'simple';
            //    const tabsContainer = document.querySelector('.tabs-container');
            //    tabsContainer.style.display = 'none';
            //}

            state.queries = { A: { filters: {}, search: "" }, B: { filters: {}, search: "" } };
            state.isEntityFilterActive = false;
            state.entityFilterIDs.clear();
            updateView();
            updateDashboard();

            
            // Désactiver tous les onglets de navigation
            document.querySelectorAll('.sidebar-nav .nav-tab').forEach(t => t.classList.remove('active'));
            // Désactiver tous les contenus
            document.querySelectorAll('.filters-wrapper .content-tab').forEach(c => c.classList.remove('active'));

            // Activer l'onglet cliqué
            const activeTab = document.querySelector(`.sidebar-nav .nav-tab[data-content="${tabName}-content"]`);
            if (activeTab) activeTab.classList.add('active');

            // Activer le contenu correspondant
            const activeContent = document.getElementById(`${tabName}-content`);
            if (activeContent) activeContent.classList.add('active');

            // NOUVEAU: Mettre à jour la visibilité de la zone A/B en fonction du mode de comparaison global.
            // Cela s'applique désormais à TOUS les contenus (opéras, entités, etc.)
            const tabsContainer = document.querySelector('.tabs-container');
            tabsContainer.style.display = (state.mode === 'compare') ? 'flex' : 'none';

            // Si on change de contenu, et qu'on est en mode comparaison, on s'assure que le contenu A/B est à jour.
            if (state.mode === 'compare') {
                if (tabName === 'operas') {
                    renderFacets();
                } else if (tabName === 'entities') {
                    // Future fonction pour initialiser/mettre à jour l'affichage des entités A/B
                }
            }
        }

        // Fonction pour gérer les nouveaux accordéons dans Entités ---
        function toggleFacetContent(headerElement) {
            const content = headerElement.nextElementSibling;
            const icon = headerElement.querySelector('i');
            
            // Toggle the open class for display/animation
            content.classList.toggle('open');
            
            // Toggle the arrow icon
            icon.className = content.classList.contains('open') ? 'fas fa-chevron-up' : 'fas fa-chevron-down';
        }

        // --- LOGIQUE D'EXPLORATION DES ENTITÉS ---

        let RAW_ENTITY_DATA = [];

        let ENTITY_DATA = {
            LOC: [],        // Lieux
            COMP_LIBR: [],  // Compositeurs/Librettistes
            THEA: [],       // Théâtres
            ACT: [],        // Acteurs/Actrices
            MISC: []        // Autres
        };

        function loadEntitiesData() {
            fetch('entity_occurrences.json')
                .then(response => {
                    if (!response.ok) throw new Error("entity_occurrences.json not found or not readable (Status: " + response.status + ")");
                    return response.json();
                })
                .then(data => {

                    RAW_ENTITY_DATA = data;

                    // Group, count, and store entities by type
                    data.forEach(item => {
                        if (ENTITY_DATA.hasOwnProperty(item.type)) {
                            // Calculate count based on the number of entries (performance IDs)
                            ENTITY_DATA[item.type].push({
                                name: item.entity,
                                type: item.type,
                                count: Object.keys(item.entries).length 
                            });
                        }
                    });

                    // Sort all lists alphabetically by name
                    for (let key in ENTITY_DATA) {
                        ENTITY_DATA[key].sort((a, b) => a.name.localeCompare(b.name));
                    }

                    // Render the lists once the data is ready
                    renderEntitiesTab();
                })
                .catch(error => {
                    console.error("Error when loading entities:", error);
                    // Display a user-friendly error in the Entités panel
                    document.getElementById('entities-content').innerHTML = 
                        `<p style="color: red; padding: 15px;">Error in data loading: ${error.message}. Check if the file is in the same folder.</p>`;
                });
        }


        function renderEntitiesTab() {
            const mapping = {
                'LOC': 'entities-loc-list',
                'COMP_LIBR': 'entities-comp-libr-list',
                'THEA': 'entities-thea-list',
                'ACT': 'entities-act-list',
                'MISC': 'entities-misc-list'
            };

            for (const type in ENTITY_DATA) {
                const listContainer = document.getElementById(mapping[type]);
                if (listContainer) {
                    listContainer.innerHTML = ''; // Clear the "Chargement..." message

                    if (ENTITY_DATA[type].length === 0) {
                        listContainer.innerHTML = `<li class="placeholder-text">No entry from this type has been found.</li>`;
                        continue;
                    }

                ENTITY_DATA[type].forEach(entity => {
                    const li = document.createElement('li');
                    li.className = 'entity-item';
                    
                    // NOUVEAU: Ajout de l'événement onclick
                    li.onclick = () => analyseEntity(entity.name, entity.type); // <--- MODIFICATION ICI
                    
                    li.innerHTML = `
                        <span class="entity-name">${entity.name}</span>
                        <span class="entity-count">${entity.count} entries</span>
                    `;
                    listContainer.appendChild(li);
                });
                }
            }
        }

        // --- LOGIQUE DE VUE DÉTAILLÉE DES ENTITÉS (Fonctions utilitaires) ---

        function showEntityList() {
           // 1. Désactiver le filtre d'entité et vider le Set d'IDs
            state.isEntityFilterActive = false;
            state.entityFilterIDs.clear(); 
            
            // Affiche la liste des entités (vue par défaut)
            document.getElementById('entity-list-view').style.display = 'block';
            document.getElementById('entity-detail-view').style.display = 'none';

            updateDashboard();
        }

        function showEntityDetail() {
            // Affiche la vue détaillée
            document.getElementById('entity-list-view').style.display = 'none';
            document.getElementById('entity-detail-view').style.display = 'block';
        }

        function renderEntryDetail(entries) {
            const listContainer = document.getElementById('detail-entry-list');
            listContainer.innerHTML = '';
            
            // Convert entries object (key=ID, value=Context Array) to a sorted array for display
            const entryIDs = Object.keys(entries).sort((a, b) => parseInt(a) - parseInt(b));

            if (entryIDs.length === 0) {
                listContainer.innerHTML = `<p class="placeholder-text">No contextual entry found for this entity.</p>`;
                return;
            }

            entryIDs.forEach(id => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'entry-item';

                // NOUVEAU: Récupération des métadonnées de l'opéra
                const opera = OPERA_METADATA[id];
                let operaDisplay = `Entry ID: ${id} (Metadata not found)`; // Fallback en cas d'erreur de correspondance

                if (opera) {
                    // Affichage formaté: Titre de l'opéra (Année)
                    operaDisplay = `${opera.titre} (${opera.annee})`;
                }


                // Map the context sentences array to HTML divs
                let contextHTML = entries[id].map(sentence => 
                    `<div class="entry-context">- ${sentence}</div>`
                ).join('');

                itemDiv.innerHTML = `
                    <div class="entry-id">${operaDisplay}</div>
                    ${contextHTML}
                `;
                
                listContainer.appendChild(itemDiv);
            });
        }

        function analyseEntity(entityName, entityType) {
            // 1. Trouver l'objet entité complet à partir du nom
            const entity = RAW_ENTITY_DATA.find(e => e.entity === entityName && e.type === entityType);

            if (!entity || !entity.entries) {
                console.error("Entities data not found or lacking entries:", entityName);
                return;
            }

            // 2. Extraire les IDs de l'entité et les convertir en entiers pour la comparaison
            const entryIDs = Object.keys(entity.entries);
            state.entityFilterIDs = new Set(entryIDs.map(id => parseInt(id))); 
            state.isEntityFilterActive = true;

            // 3. Mettre à jour le titre de la vue détaillée
            document.getElementById('detail-entity-name').textContent = `${entityName}`;

            // 4. Rendre les détails des entrées
            renderEntryDetail(entity.entries);

            // 5. Changer la vue
            showEntityDetail();

            updateDashboard();
        }

        // --- MOTEUR DE RENDU ---
        function updateDashboard() {
            // 1. Calculer les résultats
            state.results.A = filterData(state.queries.A);
            state.results.B = state.mode === 'compare' ? filterData(state.queries.B) : [];

            // 2. Gestion de l'affichage Carte (MODIFIÉ)
            if (state.vizMode === 'heatmap') {
                // Mode Heatmap : On efface les points et on dessine la chaleur
                layers.A.clearLayers();
                layers.B.clearLayers();
                updateHeatmapLayer();
            } else {
                // Mode Points : On s'assure que la heatmap est partie
                if (heatLayer) map.removeLayer(heatLayer);
                
                // On dessine les points comme avant
                updateMapLayer('A', state.results.A, '#9e2a2b');
                updateMapLayer('B', state.results.B, '#219ebc');
            }

            // 3. Histogramme
            updateHistogram();

            // 4. Compteurs
            document.getElementById('count-a').innerText = state.results.A.length;
            document.getElementById('count-b').innerText = state.results.B.length;
        }

        function filterData(q) {
            const [s, e] = state.range;

            if (!state.data) return [];

            return state.data.filter(f => {
                const p = f.properties;

                if (state.isEntityFilterActive) {
                    // L'opéra doit faire partie des IDs (p.id) stockés par l'entité cliquée
                    // Note: p.id est supposé être un nombre, state.entityFilterIDs contient des nombres.
                    if (!state.entityFilterIDs.has(p.id)) {
                        return false;
                    }
                }

                // Temps
                if(p.annee < s || p.annee > e) return false;
                
                // Recherche (CORRECTION 1.a: Ajout de la recherche sur theatre et compositeur)
                if(q.search) {
                    const txt = (p.titre + " " + (p.theatre || '') + " " + (p.compositeur || '')).toLowerCase();
                    if(!txt.includes(q.search.toLowerCase())) return false;
                }
                
                // Facettes
                for(let k in q.filters) {
                    // Utilise .has() pour vérifier l'existence dans le Set des filtres actifs
                    if(q.filters[k].size > 0 && !q.filters[k].has(p[k])) return false;
                }
                return true;
            });
        }

        // --- VISUALISATION (CARTE & ANIMATION) ---
        function updateMapLayer(layerKey, dataset, color) {
            const group = layers[layerKey];
            const refs = markersRef[layerKey];
            
            // Agrégation
            let venues = {};
            // Initialiser tous les théâtres connus à 0 pour permettre le rétrécissement
            Object.keys(refs).forEach(k => {
                // S'assurer que le marqueur est toujours sur la carte même avec count 0 pour l'animation
                venues[k] = {count:0, coords: refs[k].getLatLng(), list:[]};
                // Si count est 0, on met le rayon à 0 pour l'animation de rétrécissement
                refs[k].setRadius(0);
            });

            dataset.forEach(f => {
                let t = f.properties.theatre;
                if(!venues[t]) venues[t] = { count:0, coords: [f.geometry.coordinates[1], f.geometry.coordinates[0]], list:[] };
                venues[t].count++;
                venues[t].list.push(f.properties);
            });

            // Dessin / Mise à jour
            Object.keys(venues).forEach(key => {
                let v = venues[key];
                let r = v.count > 0 ? Math.sqrt(v.count) * 6 + 2 : 0; // Rayon cible

                if (refs[key]) {
                    // Le marqueur existe, on change son rayon (CSS transition fera le reste)
                    refs[key].setRadius(r);
                    if(v.count > 0) refs[key].bindPopup(buildPopup(key, v));
                } else if (v.count > 0) {
                    // Création
                    let m = L.circleMarker(v.coords, {
                        radius: 0, color: color, fillColor: color, fillOpacity: 0.6, weight: 1
                    });
                    m.bindPopup(buildPopup(key, v));
                    m.addTo(group);
                    refs[key] = m;
                    setTimeout(() => m.setRadius(r), 10); // Animation entrée
                }
            });
            
            // S'assurer que les marqueurs sans données sont retirés de la carte pour éviter les résidus
            Object.keys(refs).forEach(k => {
                if(!venues[k] && refs[k]) {
                    group.removeLayer(refs[k]);
                    delete refs[k];
                }
            });
        }

        function buildPopup(title, data) {
            let html = `<strong>${title}</strong><br>${data.count} Operas<br><hr style="margin:5px 0; border:0; border-top:1px solid #eee">`;
            data.list.slice(0,5).forEach(o => html += `<div style="font-size:0.9em">${o.annee}: ${o.titre}</div>`);
            if(data.list.length > 5) html += `<em>...and ${data.list.length-5} others</em>`;
            return html;
        }

        // --- HISTOGRAMME ---
        function updateHistogram() {
            // Echelle Globale
            // NOTE: The globalCounts and max calculation MUST be based on the ENTIRE dataset 
            // for the gray background bars to represent the total density.
            let globalCounts = {}, max = 0;
            
            // Assuming state.data is the full, unfiltered list of features
            state.data.forEach(f => {
                globalCounts[f.properties.annee] = (globalCounts[f.properties.annee]||0)+1;
                if(globalCounts[f.properties.annee] > max) max = globalCounts[f.properties.annee];
            });


            // NOUVEAU: getDist prend maintenant les résultats filtrés (déjà calculés dans updateDashboard)
            const getDist = (results) => {
                let c = {};
                // Nous itérons sur les résultats déjà filtrés (results)
                results.forEach(f => c[f.properties.annee] = (c[f.properties.annee]||0)+1);
                return c;
            };

            // MODIFICATION CRITIQUE: Utiliser state.results.A et state.results.B
            // Ces variables contiennent les données filtrées par filterData(), y compris le filtre Entité
            let cA = getDist(state.results.A);
            let cB = state.mode === 'compare' ? getDist(state.results.B) : {};

             for(let y=CONFIG.min; y<=CONFIG.max; y++) {
                let el = document.getElementById('h-'+y);
                if (!el) continue;
                
                // Calculs existants
                let valGlobal = globalCounts[y]||0;
                let valA = cA[y]||0;
                let valB = cB[y]||0;

                let hBg = max ? valGlobal/max*100 : 0;
                let hA  = max ? valA/max*100 : 0;
                let hB  = max ? valB/max*100 : 0;
                
                // Mise à jour visuelle
                el.querySelector('.bar-bg').style.height = hBg+'%';
                el.querySelector('.bar-a').style.height = hA+'%';
                el.querySelector('.bar-b').style.height = hB+'%';
                el.style.opacity = (y >= state.range[0] && y <= state.range[1]) ? 1 : 0.3;

                // --- AJOUT POUR FEATURE B : Stockage des données pour le tooltip ---
                el.setAttribute('data-year', y);
                el.setAttribute('data-total', valGlobal);
                el.setAttribute('data-a', valA);
                el.setAttribute('data-b', valB);
            }
        }

        // --- UI GENERATION ---
        const FACETS = [
            {key:'theatre', label:'Théâtres'}, 
            {key:'compositeur', label:'Compositeurs'}, 
            {key:'librettiste', label:'Librettistes'}
        ];

        function renderFacets() {
            const container = document.getElementById('facets-output');
            container.innerHTML = '';
            
            const q = state.queries[state.activeTab];

            FACETS.forEach(facet => {
                // Comptes (Comptes globaux, ou on pourrait faire les comptes selon la recherche active - ici: global)
                let counts = {};
                state.data.forEach(f => {
                    let v = f.properties[facet.key];
                    if(v) counts[v] = (counts[v]||0)+1;
                });

                let group = document.createElement('div');
                group.className = 'facet-group';
                
                // Header
                let header = document.createElement('div');
                header.className = 'facet-header';
                header.innerHTML = `<span>${facet.label}</span> <i class="fas fa-chevron-down"></i>`;
                
                // Content
                let content = document.createElement('div');
                content.className = 'facet-content';
                
                header.onclick = () => {
                    content.classList.toggle('open');
                    header.querySelector('i').className = content.classList.contains('open') ? 'fas fa-chevron-up' : 'fas fa-chevron-down';
                };

                Object.keys(counts).sort().forEach(val => {
                    let checked = q.filters[facet.key] && q.filters[facet.key].has(val);
                    let row = document.createElement('div');
                    row.className = 'checkbox-item';
                    row.innerHTML = `
                        <div style="display:flex; align-items:center">
                            <input type="checkbox" ${checked?'checked':''} style="margin-right:8px"> ${val}
                        </div>
                        <span class="count-badge">${counts[val]}</span>
                    `;
                    row.querySelector('input').onchange = (e) => toggleFilter(facet.key, val, e.target.checked);
                    content.appendChild(row);
                });

                group.appendChild(header);
                group.appendChild(content);
                container.appendChild(group);
            });
        }

        // --- OUTILS ---
        function resetCurrent() {
            state.queries[state.activeTab] = { filters: {}, search: "" };
            // Correction 1.a: Réinitialiser l'input de recherche et rafraîchir les facettes
            document.getElementById('searchInput').value = "";
            renderFacets(); 
            updateDashboard();
        }

        function exportData() {
            // Export des données actives (A si simple, ou A+B si compare? faisons Simple: exporte la vue active)
            let dataToExport = state.results[state.activeTab];
            if(!dataToExport.length) return alert("Aucune donnée visible.");
            
            let keys = Object.keys(dataToExport[0].properties);
            let csv = keys.join(",") + "\n";
            dataToExport.forEach(f => {
                csv += keys.map(k => `"${(f.properties[k]||"").toString().replace(/"/g, '""')}"`).join(",") + "\n";
            });
            
            let link = document.createElement("a");
            link.href = "data:text/csv;charset=utf-8," + encodeURI(csv);
            link.download = `opera_export_${state.activeTab}.csv`;
            link.click();
        }

        function toggleMenu() {
            let el = document.getElementById('menu-overlay');
            el.style.display = (el.style.display === 'flex') ? 'none' : 'flex';
        }

        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            let isDark = document.body.classList.contains('dark-mode');
            // Met à jour l'état de la checkbox dans le modal
            document.getElementById('darkModeToggle').checked = isDark; 
            changeMapStyle(isDark ? 'dark_all' : 'voyager');
        }

        function changeMapStyle(style) {
            if(tileLayer) map.removeLayer(tileLayer);
            tileLayer = L.tileLayer(`https://{s}.basemaps.cartocdn.com/rastertiles/${style}/{z}/{x}/{y}{r}.png`, {
                attribution: '&copy; CARTO',
                crossOrigin: true
            }).addTo(map);
            // layers.A.bringToFront(); layers.B.bringToFront();
        }

        function togglePlay() {
            state.isPlaying = !state.isPlaying;
            let btn = document.getElementById('play-icon');
            btn.className = state.isPlaying ? "fas fa-pause" : "fas fa-play";
            
            if(state.isPlaying) {
                let span = state.range[1] - state.range[0];
                let cur = state.range[0];
                playInterval = setInterval(() => {
                    cur++;
                    // Si l'année de fin de la fenêtre glissante dépasse la limite max
                    if(cur + span > CONFIG.max) {
                        togglePlay(); // Arrête la lecture
                        return;
                    }
                    slider.set([cur, cur+span]);
                }, 800);
            } else {
                clearInterval(playInterval);
            }
        }

        // --- FONCTIONS D'EXPORT IMAGE & GIF (Corrigées) ---

        function getCaptureArea() {
            // Calcul dynamique de la zone à droite de la sidebar
            const sidebarEl = document.getElementById('sidebar');
            const sidebarWidth = sidebarEl.offsetWidth;
            const totalWidth = document.body.clientWidth;
            const totalHeight = document.body.clientHeight;

            return {
                x: sidebarWidth,
                y: 0,
                width: totalWidth - sidebarWidth,
                height: totalHeight
            };
        }

        // 1. Capture d'écran (Image PNG - Sans la sidebar)
        async function takeScreenshot() {
            const sidebar = document.getElementById('sidebar');
            const prevDisplay = sidebar.style.display;
            const prevGridCols = document.body.style.gridTemplateColumns;
            const prevGridAreas = document.body.style.gridTemplateAreas;

            // 1. Étendre la carte
            sidebar.style.display = 'none';
            document.body.style.gridTemplateColumns = '1fr';
            document.body.style.gridTemplateAreas = '"map" "timeline"';
            window.scrollTo(0,0);

            // 2. Attendre que Leaflet redessine le Canvas (Important)
            await new Promise(resolve => {
                map.invalidateSize();
                // Délai pour laisser le temps au moteur de rendu canvas de se caler
                setTimeout(resolve, 800); 
            });

            // 3. Capture
            html2canvas(document.body, {
                useCORS: true,
                // scale: 2, // Décommentez pour une meilleure résolution
            }).then(canvas => {
                // Restauration
                sidebar.style.display = prevDisplay;
                document.body.style.gridTemplateColumns = prevGridCols;
                document.body.style.gridTemplateAreas = prevGridAreas;
                map.invalidateSize();

                // Téléchargement
                let link = document.createElement('a');
                link.download = `Capture_Opera_${new Date().toISOString().slice(0,10)}.png`;
                link.href = canvas.toDataURL("image/png");
                link.click();
            }).catch(err => {
                console.error(err);
                alert("Erreur de capture");
                // Restauration de secours
                sidebar.style.display = prevDisplay;
                document.body.style.gridTemplateColumns = prevGridCols;
                document.body.style.gridTemplateAreas = prevGridAreas;
                map.invalidateSize();
            });
        }
        // --- FEATURE B LOGIC: Event Listeners ---
        // Fonction "Interrupteur" qui gère le clic bouton
        function toggleRecording() {
            const recBtn = document.getElementById('rec-btn');
            const statusText = document.getElementById('export-status');
            const overlay = document.getElementById('export-overlay');
            const mapDiv = document.getElementById('map');
            const sliderEl = document.getElementById('time-slider');

            // Cas 1 : ARRÊT DEMANDÉ
            if (state.isRecording) {
                state.isRecording = false; 
                
                recBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>'; 
                statusText.innerText = "Arrêt demandé... Finition du GIF...";
                return;
            }

            // Cas 2 : DÉMARRAGE
            state.isRecording = true;
            recBtn.innerHTML = '<i class="fas fa-stop"></i>'; 
            recBtn.classList.add('recording');
            
            // --- LE CORRECTIF ROBUSTE ---
            
            // 1. On rend l'overlay "fantôme" : on le voit, mais les clics passent au travers
            overlay.style.pointerEvents = 'none';
            
            // 2. On désactive tout ce qui est en dessous, SAUF le bouton
            mapDiv.style.pointerEvents = 'none';     // Impossible de bouger la carte
            sliderEl.style.pointerEvents = 'none';   // Impossible de toucher au slider
            
            // 3. On s'assure que le bouton reste cliquable (par sécurité)
            recBtn.style.pointerEvents = 'auto';
            recBtn.style.position = 'relative'; 
            recBtn.style.zIndex = '10000'; // Pour qu'il soit visuellement au-dessus du gris
            
            // ----------------------------
            
            startRecordingProcess();
        }
        // La mécanique d'enregistrement (ex-startRecording)
        function startRecordingProcess() {
            // 1. Initialisation
            if (state.isPlaying) togglePlay();

            const overlay = document.getElementById('export-overlay');
            const statusText = document.getElementById('export-status');
            
            // Sauvegardes
            const mapCenter = map.getCenter();
            const sidebar = document.getElementById('sidebar');
            const prevDisplay = sidebar.style.display;
            const prevGridCols = document.body.style.gridTemplateColumns;
            const prevGridAreas = document.body.style.gridTemplateAreas;

            overlay.style.display = 'flex'; 
            statusText.innerText = "Initialisation...";

            const w = document.documentElement.clientWidth;
            const h = document.documentElement.clientHeight;

            // 2. Configuration du GIF
            const gif = new GIF({
                workers: 2,
                quality: 1, // Haute qualité
                workerScript: 'gif.worker.js',
                width: w,
                height: h,
                transparent: 'rgba(0,0,0,0)'
            });

            // 3. Séquence
            let currentYearStart = state.range[0];
            const span = state.range[1] - state.range[0];
            const stepsToRecord = 50;
            let frameCount = 0;

            // Préparation Carte
            const prepareMapForCapture = () => {
                return new Promise(resolve => {
                    sidebar.style.display = 'none';
                    document.body.style.gridTemplateColumns = '1fr';
                    document.body.style.gridTemplateAreas = '"map" "timeline"';
                    window.scrollTo(0, 0); 
                    
                    map.once('resize', () => {
                        map.panTo(mapCenter, { animate: false });
                        setTimeout(() => resolve(), 800); 
                    });
                    
                    map.invalidateSize(); 
                    // Sécurité si l'event resize ne part pas
                    setTimeout(() => resolve(), 2000); 
                });
            };

            const captureFrame = async () => {
                // --- VÉRIFICATION D'ARRÊT ---
                // On arrête si : 
                // 1. Le nombre d'étapes est atteint
                // 2. La date max est atteinte
                // 3. OU si l'utilisateur a cliqué sur STOP (state.isRecording est passé à false)
                if (frameCount >= stepsToRecord || 
                (currentYearStart + frameCount + span) > CONFIG.max || 
                !state.isRecording) { // <--- C'est ici que l'arrêt manuel agit
                    
                    statusText.innerText = "Génération du GIF... (Ne fermez pas)";
                    await new Promise(r => setTimeout(r, 100)); 
                    gif.render();
                    return;
                }

                const newStart = currentYearStart + frameCount;
                slider.set([newStart, newStart + span]);
                statusText.innerText = `Enregistrement... ${newStart} (Appuyez sur Stop pour finir)`;

                await new Promise(r => setTimeout(r, 150));

                try {
                    const canvas = await html2canvas(document.body, {
                        useCORS: true,
                        preferCanvas: true,
                        scale: 1, 
                        width: w,
                        height: h,
                        windowWidth: w,
                        windowHeight: h,
                        x: 0, y: 0, scrollX: 0, scrollY: 0,
                        ignoreElements: (element) => element.id === 'export-overlay'
                    });

                    gif.addFrame(canvas, {delay: 500});
                    frameCount++;
                    
                    // On continue seulement si l'utilisateur n'a pas appuyé sur stop pendant la capture
                    if(state.isRecording) {
                        captureFrame();
                    } else {
                        // Si l'utilisateur a appuyé sur stop PENDANT html2canvas, on lance le rendu direct
                        gif.render();
                    }

                } catch (err) {
                    console.error(err);
                    resetUI();
                }
            };

            // 4. Fin
            gif.on('finished', function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `opera_venice_${new Date().toISOString().slice(0,10)}.gif`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                resetUI();
            });

            function resetUI() {
                // Restauration layout
                sidebar.style.display = prevDisplay;
                document.body.style.gridTemplateColumns = prevGridCols;
                document.body.style.gridTemplateAreas = prevGridAreas;
                map.invalidateSize(); 
                
                // Reset Bouton
                const recBtn = document.getElementById('rec-btn');
                recBtn.classList.remove('recording');
                recBtn.innerHTML = '<i class="fas fa-video"></i>'; 
                state.isRecording = false; 

                // Reset Overlay et Slider
                overlay.style.display = 'none';
                slider.set([currentYearStart, currentYearStart + span]);

                // --- LE CORRECTIF (On réactive tout) ---
                const mapDiv = document.getElementById('map');
                const sliderEl = document.getElementById('time-slider');
                
                overlay.style.pointerEvents = '';
                mapDiv.style.pointerEvents = '';
                sliderEl.style.pointerEvents = '';
                
                recBtn.style.pointerEvents = '';
                recBtn.style.position = '';
                recBtn.style.zIndex = '';
                // ---------------------------------------
            }

            prepareMapForCapture().then(() => {
                captureFrame();
            });
        }
        // --- FEATURE C: SCROLLYTELLING DATA & LOGIC ---

        const TOUR_STEPS = [
            {
                start: 1637, end: 1645,
                title: "1637 : L'Aube de l'Opéra Public",
                text: "Tout commence ici. Avec l'ouverture du Teatro San Cassiano, l'opéra cesse d'être un divertissement de cour exclusif pour devenir un spectacle public payant. Venise devient le laboratoire de l'Europe musicale."
            },
            {
                start: 1650, end: 1660,
                title: "L'Expansion (1650-1660)",
                text: "Le succès est foudroyant. De nouveaux théâtres ouvrent (SS. Giovanni e Paolo, San Moisè). La concurrence pousse les librettistes et compositeurs (comme Cavalli) à innover. Observez la multiplication des points sur la carte."
            },
            {
                start: 1680, end: 1700,
                title: "L'Âge d'Or Vénitien",
                text: "À la fin du siècle, Venise compte plus de théâtres d'opéra actifs que n'importe quelle autre ville au monde. C'est l'époque du tourisme musical international. La densité au centre de la ville est maximale."
            },
            {
                start: 1740, end: 1750,
                title: "Le Tournant du Siècle",
                text: "Le style change, l'Opera Seria s'impose, mais Venise reste une capitale incontournable. Goldoni commence à réformer le livret. La répartition géographique reste dense autour du Grand Canal."
            }
        ];

        let currentStepIndex = -1;

        function startTour() {
            // Reset view
            if(state.mode === 'compare') toggleMode(); // Force mode simple
            switchSidebarTab('operas'); // Vue principale
            resetCurrent(); // Reset filtres
            
            currentStepIndex = 0;
            document.getElementById('tour-overlay').style.display = 'block';
            applyTourStep();
        }

        function applyTourStep() {
            const step = TOUR_STEPS[currentStepIndex];
            
            // 1. Mise à jour Slider & Map
            slider.set([step.start, step.end]);
            
            // 2. Mise à jour Texte
            document.getElementById('tour-title').innerText = step.title;
            document.getElementById('tour-text').innerText = step.text;
            
            // 3. Gestion bouton "Suivant/Fin"
            const nextBtn = document.querySelector('#tour-overlay .btn-export');
            if(currentStepIndex === TOUR_STEPS.length - 1) {
                nextBtn.innerHTML = 'Terminer <i class="fas fa-check"></i>';
                nextBtn.onclick = endTour;
            } else {
                nextBtn.innerHTML = 'Suivant <i class="fas fa-chevron-right"></i>';
                nextBtn.onclick = nextTourStep;
            }
        }

        function nextTourStep() {
            if(currentStepIndex < TOUR_STEPS.length - 1) {
                currentStepIndex++;
                applyTourStep();
            }
        }

        function endTour() {
            document.getElementById('tour-overlay').style.display = 'none';
            // Remettre le slider sur toute la période ? Ou laisser tel quel ?
            // slider.set([CONFIG.min, CONFIG.max]); // Optionnel
        }

        function toggleHeatmap() {
            const isHeat = document.getElementById('heatmapToggle').checked;
            state.vizMode = isHeat ? 'heatmap' : 'points';
            
            // Si on active la heatmap, on cache les points, sinon on les réaffiche
            if (state.vizMode === 'points') {
                if (heatLayer) {
                    map.removeLayer(heatLayer);
                    heatLayer = null;
                }
                updateDashboard();
            } else {
                // Mode Heatmap activé
                layers.A.clearLayers();
                layers.B.clearLayers();
            }
            markersRef = { A: {}, B: {} };
            
            updateDashboard();
        }
        function updateHeatmapLayer() {
            // 1. Récupérer toutes les données actives (A et B si comparaison)
            let allData = [...state.results.A];
            if (state.mode === 'compare') {
                allData = allData.concat(state.results.B);
            }

            // 2. Agréger par coordonnées pour l'intensité
            // Leaflet.heat prend des points [lat, lng, intensité]
            // Intensité = nombre d'opéras dans ce théâtre sur la période
            let pointsMap = {};
            let maxCount = 0;

            allData.forEach(f => {
                // Clé unique basée sur les coordonnées pour grouper les théâtres
                const key = f.geometry.coordinates.join(',');
                if (!pointsMap[key]) {
                    pointsMap[key] = {
                        lat: f.geometry.coordinates[1],
                        lng: f.geometry.coordinates[0],
                        count: 0
                    };
                }
                pointsMap[key].count++;
                if (pointsMap[key].count > maxCount) maxCount = pointsMap[key].count;
            });

            // 3. Préparer le tableau pour Leaflet.heat
            // L'intensité est normalisée entre 0 et 1 (count / maxCount) pour un meilleur rendu visuel
            const heatPoints = Object.values(pointsMap).map(p => {
                return [p.lat, p.lng, p.count * 1.5]; // *1.5 pour booster un peu la couleur
            });

            // 4. Gestion du Layer Leaflet
            if (heatLayer) {
                // Mise à jour des données si le layer existe déjà
                heatLayer.setLatLngs(heatPoints);
                heatLayer.addTo(map);
            } else {
                // Création initiale
                heatLayer = L.heatLayer(heatPoints, {
                    radius: 25, // Rayon de la chaleur
                    blur: 15,   // Flou
                    maxZoom: 17,
                    gradient: {0.4: 'blue', 0.65: 'lime', 1: 'red'} // Dégradé de couleur
                }).addTo(map);
            }
        }

    </script>
</body>
</html>