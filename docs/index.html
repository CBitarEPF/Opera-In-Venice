<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Opera Venetia: Comparative Analytics</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet & noUiSlider CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.css" />
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            /* Couleurs sémantiques pour la comparaison */
            --color-a: #d62828; /* Rouge Vénitien */
            --color-b: #219ebc; /* Bleu Lagune */
            --color-bg-bar: #e0e0e0;
            
            --bg-panel: #ffffff;
            --text-main: #2b2d42;
            --border: #e9ecef;
            --bg-map: #f0f0f0;
        }

        /* Dark Mode Variables */
        body.dark-mode {
            --bg-panel: #1a1a1a;
            --text-main: #e0e0e0;
            --border: #333;
            --bg-map: #121212;
            --color-bg-bar: #333;
        }

        body {
            margin: 0; padding: 0;
            font-family: 'Lato', sans-serif;
            color: var(--text-main);
            background: var(--bg-panel);
            display: grid;
            height: 100vh; width: 100vw;
            grid-template-columns: 340px 1fr; 
            grid-template-rows: 60px 1fr 140px; /* Header | Map | Timeline */
            grid-template-areas: 
                "sidebar header"
                "sidebar map"
                "sidebar timeline";
            overflow: hidden;
            transition: background 0.3s, color 0.3s;
        }

        /* --- 1. SIDEBAR (Filtres Comparative) --- */
        #sidebar {
            grid-area: sidebar;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex; flex-direction: column;
            z-index: 2000;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }

        .sidebar-title {
            padding: 20px;
            font-family: 'Playfair Display', serif;
            font-size: 20px; border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
        }
        
        /* Onglets A / B */
        .query-tabs {
            display: flex; border-bottom: 1px solid var(--border);
        }
        .query-tab {
            flex: 1; padding: 15px; text-align: center; cursor: pointer;
            font-weight: bold; border-bottom: 3px solid transparent; opacity: 0.6;
            transition: all 0.2s;
        }
        .query-tab:hover { opacity: 1; background: rgba(0,0,0,0.02); }
        .query-tab.active { opacity: 1; }
        
        .tab-a.active { border-bottom-color: var(--color-a); color: var(--color-a); background: rgba(214, 40, 40, 0.05); }
        .tab-b.active { border-bottom-color: var(--color-b); color: var(--color-b); background: rgba(33, 158, 188, 0.05); }

        /* Zone de filtre */
        .filters-wrapper { flex-grow: 1; overflow-y: auto; padding: 0 20px; position: relative; }
        
        /* Recherche et Facettes */
        .search-box { margin: 15px 0; }
        .search-input {
            width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
            background: var(--bg-panel); color: var(--text-main);
        }

        .facet-group { margin-bottom: 15px; border-bottom: 1px solid var(--border); padding-bottom: 10px; }
        .facet-header { font-weight: bold; font-size: 12px; text-transform: uppercase; cursor: pointer; display: flex; justify-content: space-between; margin-bottom: 5px; }
        .facet-content { display: none; max-height: 200px; overflow-y: auto; }
        .facet-content.open { display: block; }
        
        .checkbox-item { display: flex; align-items: center; font-size: 13px; padding: 3px 0; cursor: pointer; }
        .checkbox-item input { margin-right: 8px; }
        
        /* Sidebar Footer */
        .sidebar-footer { padding: 15px; border-top: 1px solid var(--border); display: flex; gap: 10px; }
        .btn { padding: 8px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold; text-transform: uppercase; flex: 1; }
        .btn-reset { background: #e9ecef; color: #333; }
        
        /* --- 2. HEADER & MENU --- */
        #top-header {
            grid-area: header;
            background: var(--bg-panel); /* Transparent sur la map ? Non, panel solid */
            display: flex; align-items: center; padding: 0 20px;
            border-bottom: 1px solid var(--border);
            justify-content: space-between;
            z-index: 1500;
        }
        .menu-btn { background: none; border: none; font-size: 20px; cursor: pointer; color: var(--text-main); }

        /* Modal Menu */
        #menu-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.6); z-index: 5000; display: none;
            justify-content: center; align-items: center;
        }
        #menu-box {
            background: var(--bg-panel); padding: 30px; border-radius: 8px; width: 400px; max-width: 90%;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }
        #menu-box h2 { margin-top: 0; font-family: 'Playfair Display'; color: var(--text-main); }
        .menu-option { margin: 15px 0; display: flex; justify-content: space-between; align-items: center; }

        /* --- 3. MAP --- */
        #map { grid-area: map; background: var(--bg-map); }
        /* Styles Leaflet custom pour les cercles */
        .marker-a { transition: r 0.5s; mix-blend-mode: multiply; }
        .marker-b { transition: r 0.5s; mix-blend-mode: multiply; }

        /* --- 4. TIMELINE --- */
        #timeline-panel {
            grid-area: timeline;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            padding: 10px 30px;
            display: flex; flex-direction: column; justify-content: center;
        }
        
        .timeline-controls { display: flex; align-items: center; margin-bottom: 5px; }
        .play-btn {
            width: 32px; height: 32px; border-radius: 50%; border: 2px solid var(--text-main);
            background: none; color: var(--text-main); cursor: pointer; margin-right: 15px;
            display: flex; justify-content: center; align-items: center;
        }
        .play-btn:hover { background: var(--text-main); color: var(--bg-panel); }

        /* Histogramme Stacked */
        #histogram {
            width: 100%; height: 50px; display: flex; align-items: flex-end; 
            margin-bottom: -10px; opacity: 0.9; pointer-events: none;
        }
        .hist-col { flex: 1; margin: 0 1px; display: flex; flex-direction: column-reverse; height: 100%; position: relative; }
        .hist-bg { position: absolute; bottom: 0; width: 100%; background: var(--color-bg-bar); z-index: 0; transition: height 0.3s; }
        /* Barres A et B superposées (absolues ou flex ?) -> Flex column reverse pour empiler */
        .hist-bar-a { width: 100%; background: var(--color-a); opacity: 0.8; transition: height 0.3s; z-index: 1; }
        .hist-bar-b { width: 100%; background: var(--color-b); opacity: 0.8; transition: height 0.3s; z-index: 1; }

        /* Slider Styles */
        #time-slider { height: 6px; margin-top: 15px; border: none; background: transparent; }
        .noUi-connect { background: #888; }
        .noUi-handle { border-radius: 50%; width: 16px; height: 16px; border: 2px solid #fff; background: #555; box-shadow: none; }
        
    </style>
</head>
<body>

    <!-- TOP HEADER -->
    <div id="top-header">
        <div style="font-weight:bold; font-family:'Playfair Display'">
            OPERA VENETIA <small style="font-weight:normal; color:#888;">| 1660-1760</small>
        </div>
        <button class="menu-btn" onclick="toggleMenu()"><i class="fas fa-bars"></i></button>
    </div>

    <!-- SIDEBAR -->
    <div id="sidebar">
        <div class="query-tabs">
            <div class="query-tab tab-a active" onclick="switchTab('A')">
                <i class="fas fa-circle" style="font-size:8px;"></i> Recherche A
            </div>
            <div class="query-tab tab-b" onclick="switchTab('B')">
                <i class="fas fa-circle" style="font-size:8px;"></i> Recherche B
            </div>
        </div>

        <div class="filters-wrapper">
            <div class="search-box">
                <input type="text" id="searchInput" class="search-input" placeholder="Filtrer (Titre, Théâtre)..." onkeyup="handleSearch()">
            </div>
            
            <!-- Facettes injectées ici -->
            <div id="facets-container"></div>
        </div>

        <div class="sidebar-footer">
            <button class="btn btn-reset" onclick="resetActiveQuery()">Reset Sélection</button>
        </div>
    </div>

    <!-- MAP -->
    <div id="map"></div>

    <!-- TIMELINE -->
    <div id="timeline-panel">
        <div class="timeline-controls">
            <button class="play-btn" onclick="togglePlay()"><i id="play-icon" class="fas fa-play"></i></button>
            <span id="date-display" style="font-weight:bold; font-size:1.1em; margin-right: 20px;">1660 - 1760</span>
            
            <!-- Légende dynamique -->
            <div style="display:flex; gap:15px; font-size:0.85em;">
                <span style="color:var(--color-a)"><i class="fas fa-circle"></i> <span id="count-a">0</span> (A)</span>
                <span style="color:var(--color-b)"><i class="fas fa-circle"></i> <span id="count-b">0</span> (B)</span>
            </div>
        </div>

        <div id="histogram"></div>
        <div id="time-slider"></div>
    </div>

    <!-- MENU MODAL -->
    <div id="menu-overlay" onclick="if(event.target==this) toggleMenu()">
        <div id="menu-box">
            <h2>Paramètres & Infos</h2>
            
            <div class="menu-option">
                <span>Mode Sombre</span>
                <input type="checkbox" onchange="toggleDarkMode()">
            </div>
            
            <div class="menu-option">
                <span>Fond de carte</span>
                <select id="mapStyleSelect" onchange="changeMapStyle(this.value)" style="padding:5px;">
                    <option value="voyager">Voyager (Clair)</option>
                    <option value="darkmatter">Dark Matter (Sombre)</option>
                    <option value="positron">Positron (Minimal)</option>
                </select>
            </div>

            <hr style="border:0; border-top:1px solid var(--border); margin:20px 0;">
            
            <div>
                <strong>Crédits</strong><br>
                <small>Développement: Assistant IA & [Votre Nom]<br>Données: Sample Dataset Venice</small>
            </div>
            <br>
            <div>
                <strong>Bibliographie</strong>
                <ul style="font-size:0.85em; padding-left:20px; margin-top:5px;">
                    <li>Alm, I. (1993). <em>Catalog of Venetian Librettos...</em></li>
                    <li>Selfridge-Field, E. (2007). <em>A New Chronology of Venetian Opera...</em></li>
                </ul>
            </div>

            <button class="btn btn-reset" style="margin-top:20px; width:100%;" onclick="toggleMenu()">Fermer</button>
        </div>
    </div>

    <!-- SCRIPTS -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.js"></script>

    <script>
        // --- 1. ETAT GLOBAL (DUAL QUERY) ---
        const CONFIG = { minYear: 1660, maxYear: 1760 };
        
        // Structure complexe pour gérer deux recherches indépendantes
        let appState = {
            data: [],
            activeTab: 'A', // 'A' ou 'B'
            
            // Paramètres de recherche pour chaque onglet
            queries: {
                A: { filters: {}, search: "" },
                B: { filters: {}, search: "" }
            },
            
            // Résultats calculés (pour éviter de recalculer tout le temps)
            results: {
                A: [], // Liste filtrée A
                B: []  // Liste filtrée B
            },
            
            timeRange: [1660, 1760],
            isPlaying: false
        };

        let map, slider, playInterval;
        let layerGroupA = L.layerGroup();
        let layerGroupB = L.layerGroup();
        let tileLayer;

        // --- 2. INITIALISATION ---
        fetch('sample_operas.geojson')
            .then(res => res.json())
            .then(geoJson => {
                appState.data = geoJson.features;
                initMap();
                initUI();
                refreshAll(); // Premier calcul
            });

        function initMap() {
            map = L.map('map', { zoomControl: false }).setView([45.436, 12.334], 14);
            L.control.zoom({ position: 'topright' }).addTo(map);
            
            changeMapStyle('voyager'); // Default
            
            layerGroupA.addTo(map);
            layerGroupB.addTo(map);
        }

        function changeMapStyle(style) {
            if(tileLayer) map.removeLayer(tileLayer);
            const url = `https://{s}.basemaps.cartocdn.com/rastertiles/${style}/{z}/{x}/{y}{r}.png`;
            tileLayer = L.tileLayer(url, {
                attribution: '&copy; CARTO', maxZoom: 20
            }).addTo(map);
            
            // S'assurer que les points restent au-dessus
            layerGroupA.bringToFront();
            layerGroupB.bringToFront();
        }

        // --- 3. LOGIQUE DE FILTRAGE (MOTEUR) ---
        
        // Fonction générique qui filtre les données selon un config de requête
        function filterData(queryConfig, startYear, endYear) {
            return appState.data.filter(f => {
                const p = f.properties;
                
                // 1. Temps
                if (p.annee < startYear || p.annee > endYear) return false;

                // 2. Recherche Texte
                if (queryConfig.search) {
                    const str = `${p.titre} ${p.compositeur} ${p.theatre} ${p.librettiste}`.toLowerCase();
                    if (!str.includes(queryConfig.search)) return false;
                }

                // 3. Facettes (AND entre catégories, OR dans la catégorie)
                for (const [key, set] of Object.entries(queryConfig.filters)) {
                    if (set.size > 0 && !set.has(p[key])) return false;
                }
                
                return true;
            });
        }

        // Met à jour TOUT (Carte, Histo, Compteurs)
        function refreshAll() {
            const [start, end] = appState.timeRange;
            
            // Calculer A
            appState.results.A = filterData(appState.queries.A, start, end);
            // Calculer B
            appState.results.B = filterData(appState.queries.B, start, end);

            updateMap();
            updateHistogram();
            updateCounters();
            updateFacetsUI(); // Met à jour les checkboxes pour refléter l'onglet actif
        }

        // --- 4. VISUALISATION CARTE (COMPARATIVE) ---
        function updateMap() {
            layerGroupA.clearLayers();
            layerGroupB.clearLayers();

            // Helper pour dessiner un set
            function drawSet(dataSet, layerGroup, color) {
                // Aggrégation par théâtre
                const venues = {};
                dataSet.forEach(f => {
                    const t = f.properties.theatre;
                    if(!venues[t]) venues[t] = { lat: f.geometry.coordinates[1], lng: f.geometry.coordinates[0], count: 0, list: [] };
                    venues[t].count++;
                    venues[t].list.push(f.properties);
                });

                Object.keys(venues).forEach(k => {
                    const v = venues[k];
                    const radius = Math.sqrt(v.count) * 5 + 2; // Taille
                    
                    const marker = L.circleMarker([v.lat, v.lng], {
                        radius: radius,
                        color: color,      // Bordure
                        weight: 2,
                        fillColor: color,  // Fond
                        fillOpacity: 0.5,  // Transparence cruciale pour la superposition A/B
                        className: color === '#d62828' ? 'marker-a' : 'marker-b'
                    });
                    
                    // Popup simple
                    let popup = `<b>${k}</b><br>${v.count} résultats<br><span style="font-size:0.8em; color:#666">Ex: ${v.list[0].titre}</span>`;
                    marker.bindPopup(popup);
                    layerGroup.addTo(map);
                });
            }

            // Si l'onglet A est actif ou a des données
            drawSet(appState.results.A, layerGroupA, getComputedStyle(document.documentElement).getPropertyValue('--color-a').trim());
            // Si l'onglet B est actif ou a des données
            drawSet(appState.results.B, layerGroupB, getComputedStyle(document.documentElement).getPropertyValue('--color-b').trim());
        }

        // --- 5. HISTOGRAMME PROPORTIONNEL ---
        function updateHistogram() {
            const container = document.getElementById('histogram');
            // Si premier passage, construire la structure DOM
            if (container.childElementCount === 0) {
                for (let y = CONFIG.minYear; y <= CONFIG.maxYear; y++) {
                    const col = document.createElement('div');
                    col.className = 'hist-col';
                    col.id = `hist-${y}`;
                    
                    // Fond (Total)
                    const bg = document.createElement('div');
                    bg.className = 'hist-bg';
                    col.appendChild(bg);
                    
                    // Barre A
                    const barA = document.createElement('div');
                    barA.className = 'hist-bar-a';
                    col.appendChild(barA);

                    // Barre B
                    const barB = document.createElement('div');
                    barB.className = 'hist-bar-b';
                    col.appendChild(barB);

                    container.appendChild(col);
                }
            }

            // 1. Calculer le total global par année (Background) pour échelle
            const globalCounts = {};
            let maxGlobal = 0;
            appState.data.forEach(f => {
                const y = f.properties.annee;
                globalCounts[y] = (globalCounts[y] || 0) + 1;
                if(globalCounts[y] > maxGlobal) maxGlobal = globalCounts[y];
            });

            // 2. Calculer les comptes A et B (indépendamment du slider, pour voir la distribution complète)
            // ATTENTION: L'histogramme doit montrer où se trouvent les données filtrées sur TOUTE la période,
            // pas seulement dans la fenêtre du slider. Donc on filtre avec minYear/maxYear.
            const fullSetA = filterData(appState.queries.A, CONFIG.minYear, CONFIG.maxYear);
            const fullSetB = filterData(appState.queries.B, CONFIG.minYear, CONFIG.maxYear);
            
            const countsA = {}, countsB = {};
            fullSetA.forEach(f => countsA[f.properties.annee] = (countsA[f.properties.annee] || 0) + 1);
            fullSetB.forEach(f => countsB[f.properties.annee] = (countsB[f.properties.annee] || 0) + 1);

            // 3. Mettre à jour le DOM
            for (let y = CONFIG.minYear; y <= CONFIG.maxYear; y++) {
                const col = document.getElementById(`hist-${y}`);
                const total = globalCounts[y] || 0;
                const valA = countsA[y] || 0;
                const valB = countsB[y] || 0;

                // Hauteurs en %
                const hTotal = maxGlobal > 0 ? (total / maxGlobal * 100) : 0;
                // A et B sont empilés ou relatifs au total ?
                // Demandé: "Montre la proportion des résultats".
                // On va dire: Hauteur barre couleur = % du résultat par rapport au Max Global
                const hA = maxGlobal > 0 ? (valA / maxGlobal * 100) : 0;
                const hB = maxGlobal > 0 ? (valB / maxGlobal * 100) : 0;

                col.querySelector('.hist-bg').style.height = `${hTotal}%`;
                col.querySelector('.hist-bar-a').style.height = `${hA}%`;
                col.querySelector('.hist-bar-b').style.height = `${hB}%`;
                
                // Opacité pour indiquer la sélection du slider
                const inRange = (y >= appState.timeRange[0] && y <= appState.timeRange[1]);
                col.style.opacity = inRange ? 1 : 0.3;
            }
        }

        // --- 6. INTERFACE UTILISATEUR (UI) ---

        function switchTab(tab) {
            appState.activeTab = tab;
            document.querySelectorAll('.query-tab').forEach(el => el.classList.remove('active'));
            document.querySelector(`.tab-${tab.toLowerCase()}`).classList.add('active');
            
            // Restaurer les inputs UI pour correspondre à la query active
            document.getElementById('searchInput').value = appState.queries[tab].search;
            updateFacetsUI();
        }

        function updateCounters() {
            document.getElementById('count-a').innerText = appState.results.A.length;
            document.getElementById('count-b').innerText = appState.results.B.length;
        }

        // Facettes
        const FACETS_CONFIG = [
            { key: 'theatre', label: 'Théâtres' },
            { key: 'compositeur', label: 'Compositeurs' },
            { key: 'librettiste', label: 'Librettistes' }
        ];

        function initUI() {
            // Générer HTML Facettes (Vide au début)
            const container = document.getElementById('facets-container');
            FACETS_CONFIG.forEach(conf => {
                const div = document.createElement('div');
                div.className = 'facet-group';
                div.innerHTML = `
                    <div class="facet-header" onclick="toggleFacet(this)">${conf.label} <i class="fas fa-chevron-down"></i></div>
                    <div class="facet-content" id="facet-${conf.key}"></div>
                `;
                container.appendChild(div);
            });

            initSlider();
            updateFacetsUI(); // Remplir checkboxes
        }

        function toggleFacet(header) {
            header.nextElementSibling.classList.toggle('open');
        }

        // Re-génère les checkboxes en fonction des données globales mais coche selon Active Query
        function updateFacetsUI() {
            const activeQuery = appState.queries[appState.activeTab];

            FACETS_CONFIG.forEach(conf => {
                const container = document.getElementById(`facet-${conf.key}`);
                // On ne vide pas tout pour ne pas perdre le scroll, idéalement, mais simple ici:
                container.innerHTML = '';

                // Compter les occurrences globales
                const counts = {};
                appState.data.forEach(f => {
                    const v = f.properties[conf.key];
                    if(v) counts[v] = (counts[v] || 0) + 1;
                });

                Object.keys(counts).sort().forEach(val => {
                    const div = document.createElement('label');
                    div.className = 'checkbox-item';
                    
                    // Est-ce coché dans la query active ?
                    const isChecked = activeQuery.filters[conf.key] && activeQuery.filters[conf.key].has(val);
                    
                    div.innerHTML = `
                        <input type="checkbox" value="${val}" ${isChecked ? 'checked' : ''} 
                               onchange="toggleFilter('${conf.key}', '${val}')">
                        ${val} <span style="margin-left:auto; color:#999; font-size:0.8em;">${counts[val]}</span>
                    `;
                    container.appendChild(div);
                });
            });
        }

        function toggleFilter(category, value) {
            const q = appState.queries[appState.activeTab];
            if (!q.filters[category]) q.filters[category] = new Set();
            
            if (q.filters[category].has(value)) {
                q.filters[category].delete(value);
            } else {
                q.filters[category].add(value);
            }
            refreshAll();
        }

        function handleSearch() {
            const val = document.getElementById('searchInput').value.toLowerCase();
            appState.queries[appState.activeTab].search = val;
            refreshAll();
        }

        function resetActiveQuery() {
            appState.queries[appState.activeTab] = { filters: {}, search: "" };
            document.getElementById('searchInput').value = "";
            refreshAll();
        }

        // --- 7. SLIDER & PLAYBACK INTELLIGENT ---
        
        function initSlider() {
            slider = noUiSlider.create(document.getElementById('time-slider'), {
                start: [1660, 1760],
                connect: true,
                range: { min: 1660, max: 1760 },
                step: 1,
                animate: false
            });

            slider.on('update', (values) => {
                const s = Math.round(values[0]);
                const e = Math.round(values[1]);
                appState.timeRange = [s, e];
                document.getElementById('date-display').innerText = (s === e) ? s : `${s} - ${e}`;
                refreshAll(); // Update map/histo visualization
            });
        }

        function togglePlay() {
            appState.isPlaying = !appState.isPlaying;
            const icon = document.getElementById('play-icon');
            icon.className = appState.isPlaying ? "fas fa-pause" : "fas fa-play";
            
            if (appState.isPlaying) startSmartPlayback();
            else clearInterval(playInterval);
        }

        function startSmartPlayback() {
            // 1. Calculer la durée actuelle de la fenêtre sélectionnée
            const currentStart = parseInt(slider.get()[0]);
            const currentEnd = parseInt(slider.get()[1]);
            const duration = currentEnd - currentStart; // Ex: 10 ans

            let cursor = currentStart;

            playInterval = setInterval(() => {
                // Avancer de 1 an
                cursor++; 
                let nextEnd = cursor + duration;

                // Si on touche la fin
                if (nextEnd > CONFIG.maxYear) {
                    // Option: Boucler ou Arrêter. Ici Arrêter.
                    togglePlay(); 
                    return;
                }

                slider.set([cursor, nextEnd]);
            }, 800); // Vitesse de lecture
        }

        // --- 8. MENU & SETTINGS ---
        function toggleMenu() {
            const el = document.getElementById('menu-overlay');
            el.style.display = (el.style.display === 'flex') ? 'none' : 'flex';
        }

        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            // Besoin de redessiner la map ? Leaflet gère mal le CSS pur pour les tiles
            // On bascule sur DarkMatter si mode sombre actif, sinon Voyager
            const isDark = document.body.classList.contains('dark-mode');
            const style = isDark ? 'darkmatter' : 'voyager';
            document.getElementById('mapStyleSelect').value = style;
            changeMapStyle(style);
        }

    </script>
</body>
</html>